}
if(is.na(turnDevs)){
if (! quiet) warning("No turning deviations given, initial values set to 0.7")
turnDevs <- 0.7
}
if (is.na(sights)) {
if (! quiet) warning("No sight ranges given, initial values set to 5")
sights <- 5
}
if (is.na(repeatAvoids)) {
if (! quiet) warning("No patch avoidance memory given. Initial values set to avoid 2 most recently visited patches")
repeatAvoids <-  2
}
if (is.na(locations)) {
if (is.na(bounds)) {
if (! quiet) warning("No bounds or locations given. Bounds set from -50 to 50 for x and y axes by default")
bounds <- st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = CRS)
}
locations <- vector("list", length = numForagers)
for(i in 1:length(locations)) locations[[i]] <- generateBoundedPoint(bounds)
} else {
if ("data.frame" %in% class(locations)) {
if(!ncol(locations) == 2) stop("locations argument must be either a list of coordinate pairs, a list of spatial points, or a dataframe with 2 columns for x and y coodinates respectively")
locationPoints <- vector("list", length = nrow(locations))
for (i in 1:length(locationPoints)) locationsPoints[[i]] <- st_point(locations[i,])
locations <- locationPoints
}
}
if(!length(locations) == numForagers) stop("number of locations given must equal value of numForagers argument")
locations <- lapply(locations, to_sf_point, crs = st_crs(bounds))
foragers <- vector("list", length = numForagers)
parameters <- st_sf(geom = reduce(locations,c), BEARING = bearings, SPEED = speeds, TURNDEV = turnDevs, SIGHT = sights, REPEATAVOID = repeatAvoids)
for (i in 1:numForagers) foragers[[i]] <- Forager(location=parameters$geom[i], bearing = parameters$BEARING[i], speed = parameters$SPEED[i], turnDev = parameters$TURNDEV[i], sight = parameters$SIGHT[i], repeatAvoid = parameters$REPEATAVOID[i])
return(foragers)
}
to_sf_point <- function(point, crs = NA) {
if (is.numeric(point)) {
if (!length(point) == 2) stop("point argument is numeric, but not of length 2")
point <- st_point(point)
}
if ("POINT" %in% class(point)) point <- st_sfc(point, crs = crs)
if ("sfc_POINT" %in% class(point)) return(point) else stop("point argument must be a numeric vector, a POINT object, or a geometry collection with POINT objects")
}
generateBoundedPoint <- function(bounds) {
location <- c(runif(1, st_bbox(bounds)["xmin"], st_bbox(bounds)["xmax"]), runif(1, st_bbox(bounds)["ymin"], st_bbox(bounds)["ymax"])) %>% st_point() %>% st_sfc(crs = st_crs(bounds))
while (!st_within(location, bounds, sparse = FALSE)[1,1]) location <- c(runif(1, st_bbox(bounds)["xmin"], st_bbox(bounds)["xmax"]), runif(1, st_bbox(bounds)["ymin"], st_bbox(bounds)["ymax"])) %>% st_point() %>% st_sfc(crs = st_crs(bounds)) #if point not within bounds, recreate
return(location)
}
setwd("~/")
BCI <- readOGR(dsn="C:/Users/avining/Documents/FFT data", layer = "BCI_outline") #load BCI shape file
sf_BCI <- st_as_sfc(BCI)
dipteryx <- readOGR(dsn="C:/Users/avining/Documents/FFT data", layer = "BCI_Dipteryx_Patches") #loads from 5 files: .dbf, .prj, .qpj, .shp, .shx
sf_dipteryx <- st_set_crs(st_as_sf(dipteryx), 32617) #converts sp dipteryx shape file into sf dataframe, then adds the CRS 32617 (UTM in zone 17N, containing Panama)
Movement_All <- read.csv("FFT data/FFT.csv")
get_dayPath_linestring <- function(dayPath) {
dayPath_linestring <- dayPath %>%
select(location.long, location.lat, timestamp) %>%
mutate(timestamp = as.numeric(as.POSIXct(timestamp))) %>%
as.matrix() %>%
st_linestring(dim = "XYM")
return(dayPath_linestring)
}
movement_sf <- Movement_All %>% ddply(.(individual.local.identifier, day), get_dayPath_linestring)
movement_sf
?ddply
get_dayPath_linestring <- function(dayPath) {
print("function call")
dayPath_linestring <- dayPath %>%
select(location.long, location.lat, timestamp) %>%
mutate(timestamp = as.numeric(as.POSIXct(timestamp))) %>%
as.matrix() %>%
st_linestring(dim = "XYM")
return(dayPath_linestring)
}
movement_sf <- Movement_All %>% ddply(.(individual.local.identifier, day), get_dayPath_linestring)
get_dayPath_linestring <- function(dayPath) {
dayPath_linestring <- dayPath %>%
select(location.long, location.lat, timestamp) %>%
mutate(timestamp = as.numeric(as.POSIXct(timestamp))) %>%
as.matrix() %>%
st_linestring(dim = "XYM")
print(dayPath_linestring)
return(dayPath_linestring)
}
movement_sf <- Movement_All %>% ddply(.(individual.local.identifier, day), get_dayPath_linestring)
get_dayPath_linestring <- function(dayPath) {
dayPath_linestring <- dayPath %>%
select(location.long, location.lat, timestamp) %>%
mutate(timestamp = as.numeric(as.POSIXct(timestamp))) %>%
as.matrix() %>%
st_linestring(dim = "XYM")
dayPath_sf <- st_sf(geom = st_sfc(dayPath_linestring))
return(dayPath_linestring)
}
movement_sf_Abby <- Movement_All %>%
filter(individual.local.identifier == "Abby 4652", day == 3) %>%
get_dayPath_linestring()
movement_sf_Abby
get_dayPath_linestring <- function(dayPath) {
dayPath_linestring <- dayPath %>%
select(location.long, location.lat, timestamp) %>%
mutate(timestamp = as.numeric(as.POSIXct(timestamp))) %>%
as.matrix() %>%
st_linestring(dim = "XYM")
dayPath_sf <- st_sf(geom = st_sfc(dayPath_linestring))
return(dayPath_sf)
}
movement_sf_Abby <- Movement_All %>%
filter(individual.local.identifier == "Abby 4652", day == 3) %>%
get_dayPath_linestring()
movement_sf_Abby
movement_sf <- Movement_All %>% ddply(.(individual.local.identifier, day), get_dayPath_linestring)
movement_sf
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
library(sf)
library(sp)
library(ggplot2)
library(geosphere)
library(stplanr)
library(units)
library(spatstat)
setwd("~/")
BCI <- readOGR(dsn="C:/Users/avining/Documents/FFT data", layer = "BCI_outline") #load BCI shape file
sf_BCI <- st_as_sfc(BCI)
dipteryx <- readOGR(dsn="C:/Users/avining/Documents/FFT data", layer = "BCI_Dipteryx_Patches") #loads from 5 files: .dbf, .prj, .qpj, .shp, .shx
sf_dipteryx <- st_set_crs(st_as_sf(dipteryx), 32617) #converts sp dipteryx shape file into sf dataframe, then adds the CRS 32617 (UTM in zone 17N, containing Panama)
Movement_All <- read.csv("FFT data/FFT.csv")
View(Movement_All)
get_dayPath_linestring <- function(dayPath) {
dayPath_linestring <- dayPath %>%
select(location.long, location.lat, timestamp, individual.taxon.canonical.name) %>%
mutate(timestamp = as.numeric(as.POSIXct(timestamp))) %>%
as.matrix() %>%
st_linestring(dim = "XYM")
dayPath_sf <- st_sf(geom = st_sfc(dayPath_linestring, crs = 32617), species = dayPath$individual.taxon.canonical.name[1])
return(dayPath_sf)
}
movement_sf <- st_sf(ddply(Movement_All, .(individual.local.identifier, day), get_dayPath_linestring))
get_dayPath_linestring <- function(dayPath) {
dayPath_linestring <- dayPath %>%
select(location.long, location.lat, timestamp) %>%
mutate(timestamp = as.numeric(as.POSIXct(timestamp))) %>%
as.matrix() %>%
st_linestring(dim = "XYM")
dayPath_sf <- st_sf(geom = st_sfc(dayPath_linestring, crs = 32617), species = dayPath$individual.taxon.canonical.name[1])
return(dayPath_sf)
}
movement_sf <- st_sf(ddply(Movement_All, .(individual.local.identifier, day), get_dayPath_linestring))
movement_sf
ggplot(movement_sf) + geom_sf(aes(color = individual.local.identifier), alpha = 0.2) + facet_wrap(~species) + geom_sf(data = sf_BCI, linetype = "longdash", fill = NA) + theme_classic()
ggplot(movement_sf) + geom_sf(aes(color = individual.local.identifier), alpha = 0.2) + facet_wrap(~species) + geom_sf(data = sf_BCI, linetype = "longdash", fill = NA) + theme_classic()
movement_sf <- st_set_crs(movement_sf, 4326)
ggplot(movement_sf) + geom_sf(aes(color = individual.local.identifier), alpha = 0.2) + facet_wrap(~species) + geom_sf(data = sf_BCI, linetype = "longdash", fill = NA) + theme_classic()
?line_bearing
diff(2,3)
?diff
diff(c(2,3))
?reduce
reduce(c(1,2,3,5), diff)
reduce(c(1,2,3,5), c)
?diff
diff(c(1,2,3,5))
?line_bearing
diff(line_bearing(movement_sf$geom[1]))
diff(line_bearing(movement_sf$geom[[1]]))
diff(line_bearing(as_Spatial(movement_sf$geom[[1]])))
?as_Spatial
diff(line_bearing(as_Spatial(st_zm(movement_sf$geom[[1]], what = "M"))))
?st_zm
diff(line_bearing(as_Spatial(st_zm(movement_sf$geom[[1]]))))
st_zm(movement_sf$geom[[1]])
as_Spatial(st_zm(movement_sf$geom[[1]]))
st_zm(movement_sf$geom)
as_Spatial(st_zm(movement_sf$geom))
line_bearing(as_Spatial(st_zm(movement_sf$geom)))
st_zm(movement_sf$geom[[1]])
as_Spatial(st_zm(movement_sf$geom[[1]]), cast = FALSE)
library(sp)
as_spatial(st_linestring(matrix(c(1:4), ncol = 2)))
as_Spatial(st_linestring(matrix(c(1:4), ncol = 2)))
as(st_zm(movement_sf$geom[[1]]), "Spatial")
as(st_zm(movement_sf$geom[1]), "Spatial")
line_bearing(as(st_zm(movement_sf$geom[1]), "Spatial"))
movement_sf$geom[1]
st_zm(movement_sf$geom[1])
plot(st_zm(movement_sf$geom[1]))
?bearing
?line_bearing
bearings_sf_1_9 <- line_bearing(flowlines_sf[1:5, ])
flowlines_sf[1:5,]
line_nearing(movement_sf[1,])
line_bearing(movement_sf[1,])
movement_sf
line_bearing(st_zm(movement_sf[1,]))
line_bearing(st_zm(movement_sf[1,]))
line_bearing(st_zm(movement_sf[1,]))
st_zm(movement_sf[1,])
bearings_sf_1_9 <- line_bearing(flowlines_sf[1:5, ])
flowlines[1:5,]
flowlines_sf[1:5,]
plot(flowlines_sf[1:5,])
plot(flowlines_sf[1:5,]$geometry)
plot(flowlines_sf[1,]$geometry)
flowlines_sf[1,]
plot(flowlines_sf[1,])
flowlines_sf[1,]
flowlines_sf$geometry[1]
?pointDistance
?st_difference
m = rbind(c(0,0), c(1,0), c(1,1), c(0,1), c(0,0))
p = st_polygon(list(m))
n = 100
l = vector("list", n)
for (i in 1:n)
l[[i]] = p + 10 * runif(2)
l
s = st_sfc(l)
s
plot(p)
plot(s)
plot(s, col = sf.colors(categorical = TRUE, alpha = .5))
d = st_difference(s)
d
plot(d, col = sf.colors(categorical = TRUE, alpha = .5))
lstring <- st_zm(movement_sf$geom[1])
lstring[1]
lstring[[1]]
lstring-lstring
lstring+lstring
st_distance(lstring)
lstring[-1]
lstring
lstring - lstring
s1 = rbind(c(0,3),c(0,4),c(1,5),c(2,5))
ls = st_linestring(s1)
seg = st_segments(ls)
install.packages("nngeo")
library(nngeo)
seg = st_segments(ls)
seg
line_bearing(st_segments(movement_sf[1,]))
warnings()
diff(line_bearing(st_segments(movement_sf[1,])))
st_segments(movement_sf)
st_segments(movement_sf[1:5,])
line_bearing(st_segments(movement_sf[1:5,]))
View(movement_sf)
View(movement_sf)
?summarize
?sf_summarize
?sf_summarise
seg
st_length(seg)
st_length(st_linesting(matrix(c(0,0,0,2,2,2), ncol = 2, byrow = TRUE)))
st_length(st_linestring(matrix(c(0,0,0,2,2,2), ncol = 2, byrow = TRUE)))
movements <- st_segments(movement_sf) %>% mutate(displacement = st_length(result), turn = line_bearing(result))
?ddply
diff(c(1,2,5))
diff(matrix(c(1,2,5,2,3,6), ncol = 2))
?group_modify
?diff
displacements <- Movement_All %>% group_by(individual.local.idenfier, day) %>% select(location.long, location.lat) %>% group_modify(~ diff(.x, lag = 1))
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(location.long, location.lat) %>% group_modify(~ diff(.x, lag = 1))
data.frame(matrix(c(1,2,5,2,3,6), ncol = 2))
diff(data.frame(matrix(c(1,2,5,2,3,6), ncol = 2)))
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(location.long, location.lat) %>% group_modify(~ diff(as.matrix(.x), lag = 1))
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(location.long, location.lat) %>% group_modify(~ data.frame(diff(as.matrix(.x), lag = 1)))
View(displacements)
Movement_UTM <- project(as.matrix(Movement_All[,c(3,4)]), "+proj=utm +zone=17N ellps=WGS84")
Movement_All[,c(3,4)] <- Movement_UTM #update long and lat columns
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(location.long, location.lat) %>% group_modify(~ data.frame(diff(as.matrix(.x), lag = 1)))
diff(Movement_All$timestamp)
timeDiff <- diff(as.POSIXct(Movement_All$timestamp))
summary(timeDiff)
timeDiff
Movement_All <- mutate(Movement_All, timestamp = as.POSIXct(timestamp))
diff(Movement_All$timestamp)
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(timestamp, location.long, location.lat) %>% group_modify(~ data.frame(diff(as.matrix(.x), lag = 1)))
Movement_All <- mutate(Movement_All, timestamp_numeric = as.numeric(as.POSIXct(timestamp)))
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(timestamp_numeric, location.long, location.lat) %>% group_modify(~ data.frame(diff(as.matrix(.x), lag = 1)))
View(displacements)
summary(displacements$timestamp_numeric)
displacements <- displacements %>% mutate(location.long = location.long * timestamp_numeric/240, location.lat = location.lat * timestamp_numeric/240)
summary(displacements)
?filter
displacements <- Movement_All %>%
group_by(individual.local.identifier, day) %>% #each group is an animals movement over one day
select(timestamp_numeric, location.long, location.lat) %>%
group_modify(~ data.frame(diff(as.matrix(.x), lag = 1))) %>% #get lagged differences in time, long, and lat for each days movement
filter(timestamp_numeric >= 180 & timestamp <= 300) #remove any displacements that were not between three and five minutes in length
displacements <- Movement_All %>%
group_by(individual.local.identifier, day) %>% #each group is an animals movement over one day
select(timestamp_numeric, location.long, location.lat) %>%
group_modify(~ data.frame(diff(as.matrix(.x), lag = 1))) %>% #get lagged differences in time, long, and lat for each days movement
filter(timestamp_numeric >= 180 & timestamp_numeric <= 300) #remove any displacements that were not between three and five minutes in length
displacements <- displacements %>% mutate(location.long = location.long * timestamp_numeric/240, location.lat = location.lat * timestamp_numeric/240)
summary(displacements)
hist(displacements$location.long)
table(displacements$location.long)
table(hist(displacements$location.long))
?arima
?group_map
displacements <- Movement_All %>%
group_by(individual.local.identifier, day) %>% #each group is an animals movement over one day
select(timestamp_numeric, location.long, location.lat) %>%
group_modify(~ data.frame(diff(as.matrix(.x), lag = 1))) %>% #get lagged differences in time, long, and lat for each days movement
filter(timestamp_numeric >= 180 & timestamp_numeric <= 300) %>% #remove any displacements that were not between three and five minutes in length
ungroup()
View(displacements)
View(displacements)
displacements <- displacements %>% mutate(location.long = location.long * timestamp_numeric/240, location.lat = location.lat * timestamp_numeric/240)
?arima
AR1models <- displacements %>% group_by(individual.local.identifier) %>% group_modify(~ broom::tidy(arima(.x, order = c(1, 0, 0))))
AR1models <- displacements %>% group_by(individual.local.identifier) %>% group_map(~ arima(.x, order = c(1, 0, 0)))
AR1models <- displacements %>% group_by(individual.local.identifier) %>% group_map(~ arima(.x$location.long, order = c(1, 0, 0)))
AR1models[[1]]
names(AR1models)
install.packages("broom")
install.packages("broom")
library(broom)
install.packages("broom")
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
library(sf)
library(sp)
library(ggplot2)
library(geosphere)
library(stplanr)
library(units)
library(spatstat)
library(broom)
install.packages(c("dplyr", "ggplot2", "maptools", "purrr", "raster", "rgdal", "rgeos", "rlang", "rmarkdown", "sf", "sp", "spData", "tibble"))
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
library(sf)
library(sp)
library(ggplot2)
library(geosphere)
library(stplanr)
library(units)
library(spatstat)
setwd("~/")
library(broom)
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
install.packages("rlang")
install.packages("rlang")
library(rlang)
library(plyr)
library(dplyr)
install.packages("rlang")
install.packages("rlang")
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
library(sf)
install.packages("vctrs")
library(devtools)
install_github("aqvining/Foraging-Simulator")
library(devtools)
install_github("aqvining/Foraging-Simulator")
library(devtools)
library(devtools)
install.packages(ellipsis)
install.packages("ellipsis")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("ps")
install.packages("ps")
install_github("aqvining/Foraging-Simulator")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("processx")
install.packages("processx")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("pkgload")
install.packages("pkgload")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("glue")
install.packages("glue")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("glue")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install_github("aqvining/Foraging-Simulator")
?stplanr
??stplanr
testEnvironment <- Environment()
library(ForageR)
test <- Environment()
test <- createForagers(3)
#' @param bearings A single numeric giving the initial bearing of all new foragers in radians or a list of numerics equal in length to the value of numForagers
#' @param speeds A single numeric giving the initial speed of all new foragers or a list of numerics equal in length to the value of numForagers
#' @param persistences A single numeric giving the initial persistence of all new foragers or a list of numerics equal in length to the value of numForagers. Ignored unless type = "BRW"
#' @param sights A single numeric giving the initial sight range of all new foragers or a list of numerics equal in length to the value of numForagers
#' @param repeatAvoids A single numeric giving the number of unique patches a forager must visit before revisting a patch, or a list of numerics equal in length to the value of numForagers
#' @param quiet A logical indicating whether to suppress warnings about default values used to fill in empty fields
#' @param CRS A numeric giving the CRS code to assign to forager locations. If bounds argument is defined, the CRS of that object will be used and this argument will be ignored
#' @param turnBiases A single numeric giving the average turn angle of a forager in radians, or a list of numerics equal in length to the value of numForagers. Ignored unless type = "BRW"
#' @export
#' @importFrom circular circular rcircularuniform rwrappedcauchy
createForagers <- function(numForagers, type = "Random", bounds = NA, locations = NA, bearings = NA, speeds = NA, persistences = NA, sights = NA, repeatAvoids = NA, quiet = FALSE, CRS = NA, turnBiases = NA) {
if (is.na(bearings)) {
if (! quiet) warning("No bearings given, initial values drawn from circular random uniform distribution")
bearings <- as.numeric(rwrappedcauchy(n = numForagers, mu = circular(0), rho = 0))
}
if(is.na(speeds)) {
if (! quiet) warning("No speeds given, initial values set to 1")
speeds <- 1
}
if (is.na(sights)) {
if (! quiet) warning("No sight ranges given, initial values set to 5")
sights <- 5
}
if (is.na(repeatAvoids)) {
if (! quiet) warning("No patch avoidance memory given. Initial values set to avoid 2 most recently visited patches")
repeatAvoids <-  2
}
if (is.na(locations)) {
if (is.na(bounds)) {
if (! quiet) warning("No bounds or locations given. Bounds set from -50 to 50 for x and y axes by default")
bounds <- st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = CRS)
}
locations <- vector("list", length = numForagers)
for(i in 1:length(locations)) locations[[i]] <- generateBoundedPoint(bounds)
} else {
if ("data.frame" %in% class(locations)) {
if(!ncol(locations) == 2) stop("locations argument must be either a list of coordinate pairs, a list of spatial points, or a dataframe with 2 columns for x and y coodinates respectively")
locationPoints <- vector("list", length = nrow(locations))
for (i in 1:length(locationPoints)) locationsPoints[[i]] <- st_point(locations[i,])
locations <- locationPoints
}
}
if (type == "BRW"){
if(is.na(persistences)){
if (! quiet) warning("No turning persistences given, initial values set to 0.7")
persistences <- 0.7
}
if(is.na(turnBiases)){
if (! quiet) warning("No turning biases given, initial values set to 0")
turnBiases <- 0
}
}
if(!length(locations) == numForagers) stop("number of locations given must equal value of numForagers argument")
locations <- lapply(locations, to_sf_point, crs = st_crs(bounds))
foragers <- vector("list", length = numForagers)
parameters <- st_sf(geom = reduce(locations,c), BEARING = bearings, SPEED = speeds, PERSISTENCE = persistences, SIGHT = sights, REPEATAVOID = repeatAvoids, BIAS = turnBiases)
if(type == "Random") for (i in 1:numForagers) foragers[[i]] <- Forager(location=parameters$geom[i], bearing = parameters$BEARING[i], speed = parameters$SPEED[i], sight = parameters$SIGHT[i], repeatAvoid = parameters$REPEATAVOID[i])
if(type == "BRW") for (i in 1:numForagers) foragers[[i]] <- BRWForager(location=parameters$geom[i], bearing = parameters$BEARING[i], speed = parameters$SPEED[i], sight = parameters$SIGHT[i], repeatAvoid = parameters$REPEATAVOID[i], persistence = parameters$PERSISTENCE[i], turnBias = parameters$BIAS[i])
return(foragers)
}
createForagers()
library(circular)
createForagers()
createForagers(3)
is.character(NA)
st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = 4623)
st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = NA)
st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = "NA")
Environment()
new("Environement")
new("Environment")
library(roxygen2)
library(devtools)
library(roxygen2)
setwd("~/Foraging Simulator")
document()
document()
warnings()
setwd("~/Foraging Simulator/R")
setwd("~/Foraging Simulator")
devtools::check()
document()
check()
build()
devtools::install_github("aqvining/ForageR")
devtools::install_github("aqvining/Foraging-Simulator")
