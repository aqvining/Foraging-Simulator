patches <- rep(st_buffer(field, dist = -2), times = 4) %>%        #start by defining the bounds within which each point should be created. Here, a single boundary defines possible space for all points, hence the use of rep
sapply(generateBoundedPoint) %>% st_sfc() %>%                               #for each boundary given, generate a spatial point within that space then store points into a spatial features collection
st_buffer(dist = 2) %>%                                          #transform generated points into circles with given patch radius
seperate_patches() %>%                                          #move any overlapping patches apart. May push patches outside of bounds
data.frame(geom = .,
NAME = as.character(1:length(.)),
MAX_VALUE = 10,
VALUE = 9,
REGEN = regen) %>% st_sf()                                 #store patch circles into a spatial features data frame with metadata
plot(patches)
plot(patches$geometry)
foragers <- createForagers(1, #number of foragers
type = "BRW", #BRW = Biased Random Walk. This is one way of defining randomness and correlation in agent movement. It inherets from a class that is purely random and can apply these methods too. Other movement types exist in the package, but this one is the most fully integrated
bounds = field,
concentrations = 0.8, #concentration variable name comes from the parameter used for a wrapped cauchy distribution, but I call the variable directedness when defining because that seems more intuitive/applicable. Will rename to add clarity
speeds = 1,
sights = 60,
giving_up_density = 0.3,
quiet = TRUE,        #prevents warnings I set up to notify users of parameters that are being set to defaults
choice_determinism = determinism, #note abbreviation for iterative loops above
efficiency = 0.1,
persistences = 0.5) #abbreviation from parameter iteration loop
simulator <- Environment(foragers = foragers, bounds = field, patches = patches)
for(step in 1:500) {
simulator$progress()
}
simulator$plotPaths()
simulator$patches$REGEN <- c(.01,0.01,0.01,0.01)
for(step in 1:500) {
simulator$progress()
}
simulator$plotPaths()
foragers <- createForagers(1, #number of foragers
type = "BRW", #BRW = Biased Random Walk. This is one way of defining randomness and correlation in agent movement. It inherets from a class that is purely random and can apply these methods too. Other movement types exist in the package, but this one is the most fully integrated
bounds = field,
concentrations = 0.8, #concentration variable name comes from the parameter used for a wrapped cauchy distribution, but I call the variable directedness when defining because that seems more intuitive/applicable. Will rename to add clarity
speeds = 1,
sights = 60,
giving_up_density = 0.3,
quiet = TRUE,        #prevents warnings I set up to notify users of parameters that are being set to defaults
choice_determinism = determinism, #note abbreviation for iterative loops above
efficiency = 0.1,
persistences = 0.5) #abbreviation from parameter iteration loop
simulator <- Environment(foragers = foragers, bounds = field, patches = patches)
for(step in 1:500) {
simulator$progress()
}
simulator$plotPaths()
library("maptools")
library("ggplot2")
dipteryx <- readOGR(dsn="\\10.126.19.90\EAS_shared\bci_general\archive\processed", layer = "BCI_Dipteryx_Patches") #loads from 5 files: .dbf, .prj, .qpj, .shp, .shx
dipteryx <- readOGR(dsn="\\10.126.19.90/EAS_shared/bci_general/archive/processed", layer = "BCI_Dipteryx_Patches") #loads from 5 files: .dbf, .prj, .qpj, .shp, .shx
library("rgeos")
dipteryx <- readOGR(dsn="\\10.126.19.90/EAS_shared/bci_general/archive/processed", layer = "BCI_Dipteryx_Patches") #loads from 5 files: .dbf, .prj, .qpj, .shp, .shx
library("ggmap")
install.packages("ggmap")
dipteryx <- readOGR(dsn="\\10.126.19.90/EAS_shared/bci_general/archive/processed", layer = "BCI_Dipteryx_Patches") #loads from 5 files: .dbf, .prj, .qpj, .shp, .shx
library("rgdal") # requires sp, will use proj.4 if installed
install.packages("rgdal")
library("rgdal") # requires sp, will use proj.4 if installed
dipteryx <- readOGR(dsn="\\10.126.19.90/EAS_shared/bci_general/archive/processed", layer = "BCI_Dipteryx_Patches") #loads from 5 files: .dbf, .prj, .qpj, .shp, .shx
setwd("\\10.126.19.90/EAS_shared/bci_general/archive/processed")
setwd("\\\\10.126.19.90/EAS_shared/bci_general/archive/processed")
dipteryx <- readOGR(dsn="\\\\10.126.19.90/EAS_shared/bci_general/archive/processed", layer = "BCI_Dipteryx_Patches") #loads from 5 files: .dbf, .prj, .qpj, .shp, .shx
#####Create a dataframe from dypterix shape files for use in ggplot
dipteryx@data$id <- as.character(dipteryx@data$PatchID)
dipteryx.points <- fortify(dipteryx, region = "PatchID")
dipteryx.df <- inner_join(dipteryx.points, dipteryx@data, by = "id")
dipteryx <- spTransform(dipteryx, CRS("+proj=longlat"))
#####Create a dataframe from dypterix shape files for use in ggplot
dipteryx@data$id <- as.character(dipteryx@data$PatchID)
dipteryx.points <- fortify(dipteryx, region = "PatchID")
dipteryx.df <- inner_join(dipteryx.points, dipteryx@data, by = "id")
plot(dipteryx)
View(dipteryx.df)
View(dipteryx.df)
zoom <- 14 #takes some trial and error to find the right zoom for your data
map <- get_map(location = c(lon = median(dipteryx.df$long, na.rm = TRUE), lat = median(dipteryx.df$lat, na.rm = TRUE)), zoom = zoom, maptype = "satellite")
library("maptools")
library("ggplot2")
library(ggmap)
map <- get_map(location = c(lon = median(dipteryx.df$long, na.rm = TRUE), lat = median(dipteryx.df$lat, na.rm = TRUE)), zoom = zoom, maptype = "satellite")
ggmap(map)
ggmap(map) + geom_polygon(dipteryx.df, aes(long, lat, group = group), color = "green", size = 1, fill = NA)
ggmap(map) + geom_polygon(data = dipteryx.df, aes(long, lat, group = group), color = "green", size = 1, fill = NA)
ggmap(map) + geom_polygon(data = dipteryx.df, aes(long, lat, group = group), color = "green", size = 1, fill = NA)
load("route_detections_sims2.Rdata")
setwd("Z:/simulations/Route_Sims")
load("route_detections_sims2.Rdata")
extract_path_data <- function(environment_list) {
#input: environment_list: A list containing an object of reference class Environment in each element
#output: a list with 2 objects. 1) a data frame with a row for each location all foragers in all environments 2)a dataframe with one row with the forager ID (keyed to first dataframe) and the simulation parameters of that forager and its environment
#description: pulls movement and properties from the Foragers in an Environment object and stores them easy to use data frames with a reference key by forager name
all_paths <- vector("list", length = length(environment_list)) #empty list for storing movement data from each environment. using a list allows for rbind to be used within an environment (assuming number of foragers is small enough that this won't be too slow), then find the total number of steps and create an empty data frame to combine all the data. Reduces processing time by avoiding rbind when many environments are simulated
total_foragers <- sum(sapply(environment_list, FUN = function(environment) length(environment$foragers))) #find total number of foragers to define number of rows in empty data frame for metadata reference
all_IDs <- data.frame(matrix(nrow = total_foragers, ncol = 5, dimnames = list(NULL, c("ID", "Persistence", "Directedness", "Choice_Determinism", "Num_Patches")))) #empty data frame for storing simulation parameters associated with each ID in all_paths
#run data extraction loops
i <- 0 #tracks the total number of foragers that have been processed
for (e in 1:length(environment_list)) {
environment_paths <- data.frame(matrix(nrow = 0, ncol = 4, dimnames = list(NULL, c("X", "Y", "Step", "ID")))) #empty storage for the paths of each forager in an environment
for (f in 1:length(environment_list[[e]]$foragers)) {
i <-  i + 1
print(paste("Extracting Data from environment ", e))
forager <-environment_list[[e]]$foragers[[f]]
id <- paste("E", e, "F", f, sep = "")
#get forager path and add to environment_paths data frame~~~~
forager_path <- forager$path %>% st_cast("POINT") %>% st_coordinates() %>% data.frame() #matrix with x,y columns for a forager
forager_path$Step <- 0:(nrow(forager_path) - 1) #first point is step zero, ensures points can always be reordered/evaluated by step number in a data frame with multiple individuals
forager_path$ID <- id
environment_paths <- rbind(environment_paths, forager_path)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#Compile meta-data ~~~~~~~~~~~~~~
all_IDs[i,] <- c(id, forager$persistence, forager$concentration, forager$choice_determinism, nrow(environment_list[[e]]$patches))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
}
all_paths[[e]] <- environment_paths
}
#~~~~~compile movement data~~~~~~~~~~~~~~~~
print("compiling all movement data . . . this will take approximately the same amount of time as data extraction")
total_steps <- sum(sapply(all_paths, nrow))
all_paths_df <- data.frame(matrix(nrow = total_steps, ncol = 4, dimnames = list(NULL, c("X", "Y", "Step", "ID"))))
i <- 0 #tracks how many steps have been added
for(e in 1:length(all_paths)) {
total_new_steps <- nrow(all_paths[[e]])
all_paths_df[(i + 1):(i + total_new_steps),] <- all_paths[[e]]
i <- i + total_new_steps
}
return(list(all_paths_df, all_IDs))
}
simulations_tidy <- extract_path_data(all_simulations)
i = 420
determinism = 1
regen = 0.2
print(paste("determinism = ", determinism, ", regen = ", regen))
field <- st_point(c(0,0)) %>% st_buffer(dist = 30) %>% st_sfc()
foragers <- createForagers(1, #number of foragers
type = "BRW", #BRW = Biased Random Walk. This is one way of defining randomness and correlation in agent movement. It inherets from a class that is purely random and can apply these methods too. Other movement types exist in the package, but this one is the most fully integrated
bounds = field,
concentrations = 0.8, #concentration variable name comes from the parameter used for a wrapped cauchy distribution, but I call the variable directedness when defining because that seems more intuitive/applicable. Will rename to add clarity
speeds = 1,
sights = 60,
giving_up_density = 0.3,
quiet = TRUE,        #prevents warnings I set up to notify users of parameters that are being set to defaults
choice_determinism = determinism, #note abbreviation for iterative loops above
efficiency = 0.1,
persistences = 0.5) #abbreviation from parameter iteration loop
patches <- rep(st_buffer(field, dist = -2), times = 4) %>%        #start by defining the bounds within which each point should be created. Here, a single boundary defines possible space for all points, hence the use of rep
sapply(generateBoundedPoint) %>% st_sfc() %>%                               #for each boundary given, generate a spatial point within that space then store points into a spatial features collection
st_buffer(dist = 2) %>%                                          #transform generated points into circles with given patch radius
seperate_patches() %>%                                          #move any overlapping patches apart. May push patches outside of bounds
data.frame(geom = .,
NAME = as.character(1:length(.)),
MAX_VALUE = 10,
VALUE = 9,
REGEN = regen) %>% st_sf()                                 #store patch circles into a spatial features data frame with metadata
simulator <- Environment(foragers = foragers, bounds = field, patches = patches)
for(step in 1:2000) {
simulator$progress()
}
all_simulations[[i]] <- simulator
save(all_simulations, file = "route_detections_sims2.Rdata")
extract_path_data <- function(environment_list) {
#input: environment_list: A list containing an object of reference class Environment in each element
#output: a list with 2 objects. 1) a data frame with a row for each location all foragers in all environments 2)a dataframe with one row with the forager ID (keyed to first dataframe) and the simulation parameters of that forager and its environment
#description: pulls movement and properties from the Foragers in an Environment object and stores them easy to use data frames with a reference key by forager name
all_paths <- vector("list", length = length(environment_list)) #empty list for storing movement data from each environment. using a list allows for rbind to be used within an environment (assuming number of foragers is small enough that this won't be too slow), then find the total number of steps and create an empty data frame to combine all the data. Reduces processing time by avoiding rbind when many environments are simulated
total_foragers <- sum(sapply(environment_list, FUN = function(environment) length(environment$foragers))) #find total number of foragers to define number of rows in empty data frame for metadata reference
all_IDs <- data.frame(matrix(nrow = total_foragers, ncol = 5, dimnames = list(NULL, c("ID", "Persistence", "Directedness", "Choice_Determinism", "Num_Patches")))) #empty data frame for storing simulation parameters associated with each ID in all_paths
#run data extraction loops
i <- 0 #tracks the total number of foragers that have been processed
for (e in 1:length(environment_list)) {
environment_paths <- data.frame(matrix(nrow = 0, ncol = 4, dimnames = list(NULL, c("X", "Y", "Step", "ID")))) #empty storage for the paths of each forager in an environment
for (f in 1:length(environment_list[[e]]$foragers)) {
i <-  i + 1
print(paste("Extracting Data from environment ", e))
forager <-environment_list[[e]]$foragers[[f]]
id <- paste("E", e, "F", f, sep = "")
#get forager path and add to environment_paths data frame~~~~
forager_path <- forager$path %>% st_cast("POINT") %>% st_coordinates() %>% data.frame() #matrix with x,y columns for a forager
forager_path$Step <- 0:(nrow(forager_path) - 1) #first point is step zero, ensures points can always be reordered/evaluated by step number in a data frame with multiple individuals
forager_path$ID <- id
environment_paths <- rbind(environment_paths, forager_path)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#Compile meta-data ~~~~~~~~~~~~~~
all_IDs[i,] <- c(id, forager$persistence, forager$concentration, forager$choice_determinism, nrow(environment_list[[e]]$patches))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
}
all_paths[[e]] <- environment_paths
}
#~~~~~compile movement data~~~~~~~~~~~~~~~~
print("compiling all movement data . . . this will take approximately the same amount of time as data extraction")
total_steps <- sum(sapply(all_paths, nrow))
all_paths_df <- data.frame(matrix(nrow = total_steps, ncol = 4, dimnames = list(NULL, c("X", "Y", "Step", "ID"))))
i <- 0 #tracks how many steps have been added
for(e in 1:length(all_paths)) {
total_new_steps <- nrow(all_paths[[e]])
all_paths_df[(i + 1):(i + total_new_steps),] <- all_paths[[e]]
i <- i + total_new_steps
}
return(list(all_paths_df, all_IDs))
}
simulations_tidy <- extract_path_data(all_simulations)
write_csv(simulations_tidy[[1]], "route_sims1_all_paths.csv")
write_csv(simulations_tidy[[1]], "route_sims2_all_paths.csv")
write_csv(simulations_tidy[[2]], "route_sims2_ID_metadata.csv")
all_paths <- read_csv("route_sims2_all_paths.csv")
ID_metadata <- read_csv("route_sims2_ID_metadata.csv")
get_step_metrics_individual <- function(individual_movement_data, x = "X", y = "Y", step_number = NA) {
#input: individual movement data; a data_frame with at least two columns containing x and y coordinate data.
#       x; character giving name of column with x coordinates
#       y; character giving name of column with y coordinates
#       step_number: name of a column with the ordered number of steps. Used to ensure proper sorting
#output: a data frame of same structure as individual_movement_data with an additional columns named "Step_length" and "Step_Turn"
#description: calculates distance traveled between all consecutive points (rows) in the data frame
if (! is.na(step_number)) individual_movement_data <- individual_movement_data[order(individual_movement_data[,step_number]),] #sort by step number
diff_x <- diff(individual_movement_data[[x]])
diff_y <- diff(individual_movement_data[[y]])
individual_movement_data$Step_length <- c(NA, mapply(FUN = function(a,b) sqrt(a^2 + b^2), a = diff_x, b = diff_y)) #first row is NA because no step has been taken, subsequent rows are hypotenuse of delta x and delta y
step_angles <- mapply(atan2, y = diff_y, x = diff_x)
step_turns <- (diff(step_angles) + pi) %% (2*pi) - pi #scales all turns from -pi to pi, rather than -2pi to 2pi which results from simple distancing, e.g. turns of -pi/2 and 3pi/2 will both be converted to -pi/2
individual_movement_data$Step_turn <- c(NA, NA, step_turns)
return(individual_movement_data)
}
#add step length and turn angle to all movement data
all_paths <- all_paths %>% group_by(ID) %>% nest() %>% #break dataframe into groups by ID and store into nested data frame for function mapping
mutate(data = map(data, get_step_metrics_individual, step_number = "Step")) %>%
unnest(cols = c(data))
#summarize step lengths and turning angles by individual
outcomes_by_ID <- all_paths %>% summarize(step_length_mean = mean(Step_length, na.rm = TRUE),
step_length_sd = sd(Step_length, na.rm = TRUE),
step_turn_mean = mean(Step_turn, na.rm = TRUE),
step_turn_sd = sd(Step_turn, na.rm = TRUE))
#functions for getting patch visit data
get_E_F_numbers <- function(ID) {
ID %>% strsplit(split = "E") %>% .[[1]] %>% strsplit(split = "F") %>% .[[2]] %>% as.numeric()
}
get_patch_visit_counts <- function(ID, all_simulations, ID_metadata) {
#extracts number of times a forager visited each patch in its environment. Uses metadata to ensure 0 visit patches ar included
IDsplit <- get_E_F_numbers(ID)
e <- IDsplit[1] #environment number
f <- IDsplit[2] #forager number
visit_sequence <- all_simulations[[e]]$foragers[[f]]$visitSeq
visit_sequence <- factor(visit_sequence, levels = as.character(1:ID_metadata$Num_Patches[ID_metadata$ID == ID]))
table(visit_sequence)
}
#add patch visit summaries to outcomes df. Sorry this is so ugly
outcomes_by_ID <- outcomes_by_ID %>% mutate(total_patch_visits = sapply(ID, function(X) sum(get_patch_visit_counts(X, all_simulations, ID_metadata))), #for each ID, get the table with counts for each possible patchs and sum
patch_visit_proportion_sd = sapply(ID, function(X) sd(get_patch_visit_counts(X, all_simulations, ID_metadata)))/total_patch_visits, #standard deviation on patch counts for each ID, normalized by total patch visits (sd on proportion of visits)
energy_extracted = sapply(ID, function(X) all_simulations[[get_E_F_numbers(X)[1]]]$foragers[[get_E_F_numbers(X)[2]]]$energy)) # for each ID, extract the energy field from the relevant forager in all_simulations
summary_data_full <- merge(ID_metadata, outcomes_by_ID, by = "ID")
View(summary_data_full)
#add patch visit summaries to outcomes df. Sorry this is so ugly
outcomes_by_ID <- outcomes_by_ID %>% mutate(total_patch_visits = sapply(ID, function(X) sum(get_patch_visit_counts(X, all_simulations, ID_metadata))), #for each ID, get the table with counts for each possible patchs and sum
patch_visit_proportion_sd = sapply(ID, function(X) sd(get_patch_visit_counts(X, all_simulations, ID_metadata)))/total_patch_visits, #standard deviation on patch counts for each ID, normalized by total patch visits (sd on proportion of visits)
energy_extracted = sapply(ID, function(X) all_simulations[[get_E_F_numbers(X)[1]]]$foragers[[get_E_F_numbers(X)[2]]]$energy), # for each ID, extract the energy field from the relevant forager in all_simulations
regen = sapply(ID, function(X) all_simulations[[get_E_F_numbers(X)[1]]]$patches$regen %>% mean()),              #for each forager ID, get the mean regen rate of patches in environment
)
warnings()
X = "E1F1"
get_E_F_numbers(X)[1]]]$patches
all_simulations[[get_E_F_numbers(X)[1]]]$patches
all_simulations[[get_E_F_numbers(X)[1]]]$patches$regen
#add patch visit summaries to outcomes df. Sorry this is so ugly
outcomes_by_ID <- outcomes_by_ID %>% mutate(total_patch_visits = sapply(ID, function(X) sum(get_patch_visit_counts(X, all_simulations, ID_metadata))), #for each ID, get the table with counts for each possible patchs and sum
patch_visit_proportion_sd = sapply(ID, function(X) sd(get_patch_visit_counts(X, all_simulations, ID_metadata)))/total_patch_visits, #standard deviation on patch counts for each ID, normalized by total patch visits (sd on proportion of visits)
energy_extracted = sapply(ID, function(X) all_simulations[[get_E_F_numbers(X)[1]]]$foragers[[get_E_F_numbers(X)[2]]]$energy), # for each ID, extract the energy field from the relevant forager in all_simulations
regen = sapply(ID, function(X) all_simulations[[get_E_F_numbers(X)[1]]]$patches$REGEN %>% mean()),              #for each forager ID, get the mean regen rate of patches in environment
)
summary_data_full <- merge(ID_metadata, outcomes_by_ID, by = "ID")
id = X
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = "), summary_data_full$regen)
simulation_plot
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen)
)
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen)
)
simulation_plot
?tiff
tiff(filename = paste("./sims2_plots/sim2_id", id, sep = ""))
simulation_plot
dev.off()
tiff(filename = paste("./sims2_plots/sim2_id", id, ".tiff", sep = ""))
simulation_plot
dev.off()
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID = id]
)
)
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID = id])
)
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID = id]))
tiff(filename = paste("./sims2_plots/sim2_id", id, ".tiff", sep = ""))
simulation_plot
dev.off()
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID = id]))
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID == id]))
tiff(filename = paste("./sims2_plots/sim2_id", id, ".tiff", sep = ""))
simulation_plot
dev.off()
id
all_simulations[[i]]$plotPaths()
all_simulations[[i]]$patches
X
all_simulations[[get_E_F_numbers(X)[1]]]$patches
i
i = 1
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID == id]))
tiff(filename = paste("./sims2_plots/sim2_id", id, ".tiff", sep = ""))
simulation_plot
dev.off()
for(id in summary_data_full$ID) {
i = get_E_F_numbers(id)[1]
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID == id]))
tiff(filename = paste("./sims2_plots/sim2_id", id, ".tiff", sep = ""))
simulation_plot
dev.off()
}
id
i = get_E_F_numbers(id)[1]
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID == id]))
simulation_plot
tiff(filename = paste("./sims2_plots/sim2_id", id, ".tiff", sep = ""))
simulation_plot
dev.off()
id = "E1F1"
i = get_E_F_numbers(id)[1]
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID == id]))
tiff(filename = paste("./sims2_plots/sim2_id", id, ".tiff", sep = ""))
simulation_plot
dev.off()
for(id in summary_data_full$ID) {
i = get_E_F_numbers(id)[1]
simulation_plot <- all_simulations[[i]]$plotPaths()
simulation_plot <- simulation_plot + labs(title = paste("Determinism = ", summary_data_full$Choice_Determinism[summary_data_full$ID == id],
" regen = ", summary_data_full$regen[summary_data_full$ID == id]))
tiff(filename = paste("./sims2_plots/sim2_id", id, ".tiff", sep = ""))
print(simulation_plot)
dev.off()
}
ggplot(summary_data_full) + geom_jitter(aes(x = regen, y = patch_visit_proportion_sd, color = choice_determinism))
ggplot(summary_data_full) + geom_jitter(aes(x = regen, y = patch_visit_proportion_sd, color = Choice_Determinism))
test = "ID"
all_paths
all_paths %>% ungroup
all_paths %>% group_by(test)
all_paths %>% group_by_at(test)
library(roxygen2)
library(devtools)
create_package(C:\Users\avining\Documents\AQV_toolbox)
create_package("C:\Users\avining\Documents\AQV_toolbox")
create_package("C:\\Users\\avining\\Documents\\AQV_toolbox")
create_package("C:\\Users\\avining\\Documents\\AQVtoolbox")
library(AQVtoolbox)
setwd("~/Foraging Simulator")
use_r("createForagers")
use_r("Environment")
use_r("Foragers")
use_r("Array_Environment")
document()
document()
warnings()
rm(list = c("id"))
document()
warnings()
install()
install()
install()
install.packages(c("data.table", "deldir", "tidyr"))
library(devtools)
install()
brwForager()
library(ForageR)
BRWForager
BRWForager()
use_r("run_full_parameter_space")
product(2,3)
prod(2:4)
document()
document()
document()
document()
warnings()
document()
library(roxygen2)
document()
document()
document()
document()
document()
check()
use_mit_license()
document()
check()
document()
check()
document()
check()
install()
library(ForageR)
use_r("extract_path_data")
document()
install()
library(ForageR)
library(ForageR)
?run
?run_full_parameter_space
?Forager
setwd("Z:/simulations/Route_Sims")
#install.packages("https://github.com/aqvining/Foraging-Simulator")
library(ForageR)
library(tidyverse)
num_patches <- 3
patch_radius <- 2 #patches will have a circular shape with given radius, inside which agents can forage
field_radius <- 50 #this radius will be used to create a bound inside which all patches and foragers will be created and can not leave
patch_clustering <- 1 #not implemented
patch_max_value <-  10
patch_starting_value <- 9
patch_regen <- 0.1
forager_directedness <- 0.5 #The concentration parameter to define a wrapped cauchy distribution from which forager bearing deviations are drawn. When 1 each step will be deterministic in direction. When 0, movement direction is fully random.
forager_persistence <- 0.6 #The weight of the direction of the foragers previous step versus the direction of a target when selecting new step direction. At 1, the forager will always move in accordance with their turnBias. At 0, they will move toward the target (with accuracy determined by concentration argument)
forager_GUD <- 0.5 #rate of return at which a forager will leave a patch
forager_choice_determinism <- 0
forager_efficiency <- 0.1 #proportion of an patch's current value which a forager extracts and adds to its energy at each time step
forager_speed <-  1 #speed of the forager, generally used as the scale parameter in a gamma distribution for drawing step lengths.
forager_sight <-  100 #the distance at which a forager can detect patches to choose from. Set to > field diameter to give foragers omniscient knowledge of the environment.
simulation_length = 2000
#Run simulations~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#First, determine the number of simulations to run and create an empty list to store them in
all_simulations <- run_full_parameter_space(num_patches = num_patches,
forager_directedness = forager_directedness,
forager_persistence = forager_persistence,
forager_choice_determinism = forager_choice_determinism,
field_radius = field_radius, patch_radius = patch_radius,
patch_max_value = patch_max_value,
patch_starting_value = patch_starting_value,
patch_regen = patch_regen,
forager_speed = forager_speed,
forager_sight = forager_sight,
forager_GUD = forager_GUD,
forager_efficiency = forager_efficiency,
simulation_length = simulation_length)
setwd("~/Foraging Simulator")
check()
check()
install()
library(ForageR)
setwd("Z:/simulations/Route_Sims")
num_patches <- 3
patch_radius <- 2 #patches will have a circular shape with given radius, inside which agents can forage
field_radius <- 50 #this radius will be used to create a bound inside which all patches and foragers will be created and can not leave
patch_clustering <- 1 #not implemented
patch_max_value <-  10
patch_starting_value <- 9
patch_regen <- 0.1
forager_directedness <- 0.5 #The concentration parameter to define a wrapped cauchy distribution from which forager bearing deviations are drawn. When 1 each step will be deterministic in direction. When 0, movement direction is fully random.
forager_persistence <- 0.6 #The weight of the direction of the foragers previous step versus the direction of a target when selecting new step direction. At 1, the forager will always move in accordance with their turnBias. At 0, they will move toward the target (with accuracy determined by concentration argument)
forager_GUD <- 0.5 #rate of return at which a forager will leave a patch
forager_choice_determinism <- 0
forager_efficiency <- 0.1 #proportion of an patch's current value which a forager extracts and adds to its energy at each time step
forager_speed <-  1 #speed of the forager, generally used as the scale parameter in a gamma distribution for drawing step lengths.
forager_sight <-  100 #the distance at which a forager can detect patches to choose from. Set to > field diameter to give foragers omniscient knowledge of the environment.
simulation_length = 2000
#Run simulations~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#First, determine the number of simulations to run and create an empty list to store them in
all_simulations <- run_full_parameter_space(num_patches = num_patches,
forager_directedness = forager_directedness,
forager_persistence = forager_persistence,
forager_choice_determinism = forager_choice_determinism,
field_radius = field_radius, patch_radius = patch_radius,
patch_max_value = patch_max_value,
patch_starting_value = patch_starting_value,
patch_regen = patch_regen,
forager_speed = forager_speed,
forager_sight = forager_sight,
forager_GUD = forager_GUD,
forager_efficiency = forager_efficiency,
simulation_length = simulation_length)
.rs.restart()
library(devtools)
library(roxygen2)
document()
install()
setwd("Z:/simulations/Route_Sims")
library(devtools)
library(roxygen2)
install()
library(devtools)
install()
library(devtools)
document()
check()
install()
