#' @importFrom circular circular rcircularuniform rwrappedcauchy
#' @import sp
#' @import ggplot2
DDBRWForager <- setRefClass("ddbrwForager", contains = "brwForager",
methods = list(
initialize = function(...) {
callSuper(...)
},
tSelect = function(choices) {
if (sum(choices$DIST == 0) > 0) return(choices[which(choices$DIST == 0),][1,])                                         #if on a patch, return that patch as target. If on multiple, return the first
choices$prob <- choices$DIST^3/sum(choices$DIST^3) #distance discounted choice
return(selector(choices))
})
)
#' newForagers <- list(Forager(), Forager())
#' #foragers are created by default between -50 and 50 on both the x and y axis
#' newPatches <- lapply(rep(2, times = 20), function(x) st_point(runif(x, min = -50, max = 50)))
#' newPatches <- newPatches %>% st_sfc %>% data.frame(geom = ., NAME = as.character(1:length(.)))
#' newPatches <- newPatches %>% st_sf() %>% st_buffer(1)
#' newBounds <- st_sfc(st_convex_hull(reduce(newPatches$geometry, c)), crs = st_crs(newPatches))
#' Environment(newForagers, newPatches, newBounds)
#' }
#' @import methods
#' @import dplyr
Environment <- setRefClass("Environment",
field = list(foragers = "list", patches = "sf", bounds = "sfc_POLYGON"),
method = list(
initialize = function(...,
patches = lapply(rep(2, times = 10), function(x) st_point(runif(x, min = -15, max = 15))) %>% st_sfc %>% data.frame(geom = ., NAME = as.character(1:length(.))) %>% st_sf() %>% st_buffer(1) %>% st_set_crs(32610),
bounds = st_sfc(st_buffer(st_convex_hull(reduce(patches$geometry, c)),1), crs = st_crs(patches)), #default bounds created as convex hull around patches with a buffer of one
foragers = createForagers(3, bounds = bounds, speed = 2, quiet = TRUE) #default creation of forager within bounds
){  "Set default values for variables that are not entered manually"
callSuper(..., foragers = foragers, patches = patches, bounds = bounds)
},
progress = function(){ "moves the entire environment forward one timestep by moving all foragers once and processing impact of foraging on patches"
for (forager in foragers[sample(length(foragers))]) {#operates on each forager in random order
if (! forager$targeting) forager$setTarget(patches) #If the forager does not currently have a target, look for one
forager$move(bounds = bounds)
}
},
plotPatches = function(){ "displays the current patch geometries"
return(ggplot(data = patches) + geom_sf(fill = "green", axes = TRUE) + theme_classic()) #plots all geometries in patches field
},
plotCurrent = function(){ "displays the current location of all foragers and patch geometries"
fLocations <- st_sf(geom = reduce(lapply(foragers, function(X) X$location),c), TYPE = as.character(sapply(foragers, class)), SPEED = sapply(foragers, function(X) X$speed)) #gets simple feature geometry column for each forager location in a list, then combines all into one simple feature geometry column
cPlot <- ggplot() + geom_sf(data = fLocations, aes(color = TYPE), shape = 13, size = 3) + geom_sf(data = patches$geometry, fill = "green") + geom_sf(data = bounds, linetype = "longdash", fill = NA) + theme_classic()
return(cPlot)
},
plotPaths = function(){ "displays the current location and path of all foragers as well as patch geometries"
cPlot <- plotCurrent()
paths <- purrr::reduce(lapply(foragers, function(X) st_cast(X$path, "LINESTRING")), c)
pathsPlot <- cPlot + geom_sf(data = paths, color = 1:length(paths))
return(pathsPlot)
})
)
library(sf)
library(sp)
library(dplyr)
library(circular)
library(purrr)
library(stats)
library(units)
library(methods)
library(sf)
#' newForagers <- list(Forager(), Forager())
#' #foragers are created by default between -50 and 50 on both the x and y axis
#' newPatches <- lapply(rep(2, times = 20), function(x) st_point(runif(x, min = -50, max = 50)))
#' newPatches <- newPatches %>% st_sfc %>% data.frame(geom = ., NAME = as.character(1:length(.)))
#' newPatches <- newPatches %>% st_sf() %>% st_buffer(1)
#' newBounds <- st_sfc(st_convex_hull(reduce(newPatches$geometry, c)), crs = st_crs(newPatches))
#' Environment(newForagers, newPatches, newBounds)
#' }
#' @import methods
#' @import dplyr
Environment <- setRefClass("Environment",
field = list(foragers = "list", patches = "sf", bounds = "sfc_POLYGON"),
method = list(
initialize = function(...,
patches = lapply(rep(2, times = 10), function(x) st_point(runif(x, min = -15, max = 15))) %>% st_sfc %>% data.frame(geom = ., NAME = as.character(1:length(.))) %>% st_sf() %>% st_buffer(1) %>% st_set_crs(32610),
bounds = st_sfc(st_buffer(st_convex_hull(reduce(patches$geometry, c)),1), crs = st_crs(patches)), #default bounds created as convex hull around patches with a buffer of one
foragers = createForagers(3, bounds = bounds, speed = 2, quiet = TRUE) #default creation of forager within bounds
){  "Set default values for variables that are not entered manually"
callSuper(..., foragers = foragers, patches = patches, bounds = bounds)
},
progress = function(){ "moves the entire environment forward one timestep by moving all foragers once and processing impact of foraging on patches"
for (forager in foragers[sample(length(foragers))]) {#operates on each forager in random order
if (! forager$targeting) forager$setTarget(patches) #If the forager does not currently have a target, look for one
forager$move(bounds = bounds)
}
},
plotPatches = function(){ "displays the current patch geometries"
return(ggplot(data = patches) + geom_sf(fill = "green", axes = TRUE) + theme_classic()) #plots all geometries in patches field
},
plotCurrent = function(){ "displays the current location of all foragers and patch geometries"
fLocations <- st_sf(geom = reduce(lapply(foragers, function(X) X$location),c), TYPE = as.character(sapply(foragers, class)), SPEED = sapply(foragers, function(X) X$speed)) #gets simple feature geometry column for each forager location in a list, then combines all into one simple feature geometry column
cPlot <- ggplot() + geom_sf(data = fLocations, aes(color = TYPE), shape = 13, size = 3) + geom_sf(data = patches$geometry, fill = "green") + geom_sf(data = bounds, linetype = "longdash", fill = NA) + theme_classic()
return(cPlot)
},
plotPaths = function(){ "displays the current location and path of all foragers as well as patch geometries"
cPlot <- plotCurrent()
paths <- purrr::reduce(lapply(foragers, function(X) st_cast(X$path, "LINESTRING")), c)
pathsPlot <- cPlot + geom_sf(data = paths, color = 1:length(paths))
return(pathsPlot)
})
)
#' @inherit Environment
#' @field foragers a list containing Reference Class objects that inherit from 'Forager' class.
#' @field patches a simple feature data frame with geometries representing patches in the geometry column
#' @field bounds a spatial features collection with one or more polygons defining the region in which any foragers can be created and moved to
#' @field sequences the names of all patches visited (in order) by foragers (only really works with a single forager currently, sequences by multiple foragers will be mixed together). Usually the defualt of an empty character is used
#' @field array the name of the array being run, if it has one
#' @field trials the number of trials that have been run. Has no effect on the environment, merely usefull as metadata. Typically uses default value of 0 at creation.
#' @export
#' @export ArrayEnvironment
#' @import methods
ArrayEnvironment <- setRefClass("ArrayEnvironment", fields= list(sequence = "character", array = "character", trials = "numeric"), contains= "Environment",
method = list(
initialize = function(..., sequence = character(0), array = "DT", trials = 0) { "Set default values for variables that are not entered manually"
callSuper(..., sequence = sequence, array = array, trials = trials)
},
progress = function(){ "Moves all foragers as desribed in parent class Environment. Then looks to see if any foragers have either visited all patches or moved 10000 steps in their current trial.
If any forager has, it's patch visitation sequence is combined with the sequence field, its location field is randomized within bounds, and its visitSeq field is reset"
callSuper()
for (forager in foragers) {
if (length(unique(forager$visitSeq[-c(1:forager$repeatAvoid)])) == length(patches) | nrow(forager$path) >= 10000) { #end conditions for trial
sequence <<- c(sequence, forager$visitSeq[-c(1:forager$repeatAvoid)])
trials <<- trials + 1
forager$location <- st_point(c(runif(1, st_bbox(bounds)["xmin"], st_bbox(bounds)["xmax"]), runif(1, st_bbox(bounds)["ymin"], st_bbox(bounds)["ymax"])))
while(! st_within(forager$location, bounds, sparse = FALSE)[1,1]) forager$location <- st_point(c(runif(1, st_bbox(bounds)["xmin"], st_bbox(bounds)["xmax"]), runif(1, st_bbox(bounds)["ymin"], st_bbox(bounds)["ymax"])))
names(forager$location) <- c("x", "y")
forager$bearing <- as.numeric(rwrappedcauchy(n = 1, mu = circular(0), rho = 0))
forager$visitSeq <- rep("NA", times = forager$repeatAvoid)
}
}
}
))
#' @field visitSeq a character vector with the names (in order) of all patches visited. Must start with NAs equal in number to to the repeatAvoid variable (this is done by default if no value is given)
#' @field targeting a logical giving which mode of movement the forager is in. Initial value usually uses default "FALSE"
#' @field repeatAvoid numeric giving the number of different patches a forager must visit before targeting a recently visited patch again
#' @field target a simple feature data frame with a single row containing the target patch location and values
#' @export
#' @export Forager
#' @import methods
#' @importFrom circular circular rcircularuniform
#' @import sp
#' @import ggplot2
Forager <- setRefClass("Forager",
field = list(location="sfc", bearing ="numeric", speed = "numeric", sight = "numeric", path = "sfc", visitSeq = "character", targeting = "logical", repeatAvoid = "numeric", target = "sf"),
method = list(initialize = function(...,location = st_sfc(st_point(runif(2, -50, 50))),
bearing = as.numeric(rcircularuniform(1)),
speed = 1, #the mean distance traveled when moving randomly, drawn from a gamma distribution with k (shape) = 1, and theta(scale) = speed. When targeting, moves at 2X speed
sight = 4,
path = st_cast(location, "MULTIPOINT"),
repeatAvoid = 2,
visitSeq = rep("NA", times = repeatAvoid),#NA's prevent errors when checking for recent visits
targeting = FALSE,
target = st_sf(st_sfc(st_multipolygon()))) {
callSuper(..., location = location, bearing = bearing, speed = speed, sight = sight, path = path, visitSeq = visitSeq, targeting = targeting, target = target, repeatAvoid = repeatAvoid)
},
setTarget = function(patches) { "checks if the location of any simple features in the geometry column of the patches argument (class sfc) are within sight range.
If so, sets target to a patch randomly selected from those within sight and then sets the targetting field to TRUE"
if (! "sf" %in% class(patches)) stop("the 'patches' argument of setTarget must be a simple feature collection")
choices <- getChoices(.self, patches)
if (! "sf" %in% class(choices)) return()
target <<- tSelect(choices)
targeting <<- TRUE
},
tSelect = function(choices) { "calculates probablilites and selects a target from a list of options but DOES NOT set the target (use setTarget for this, which calls tSelect). A forager will always select a patch it is on if possible. Otherwise, selection is random"
if (sum(choices$DIST == 0) > 0) return(choices[which(choices$DIST == 0),][1,])     #if on a patch, return that patch as target. If on multiple, return the first
choices$prob <- rep(1/nrow(choices), times = nrow(choices)) #random choice
return(selector(choices))
},
move = function(bounds = NA) {"moves the forager using rules given in class description. Updates relevant fields including location, bearing, visitSeq, bearing, targetting, and path"
if (targeting) { #if a target is given, assess proximity and action
bearing <<- lineBearing(st_nearest_points(st_set_crs(st_sfc(location), st_crs(target)), target)) #set bearing toward target
if (abs(set_units(st_distance(location, target$geometry), NULL)) <= 2 * speed) { #if target is in reach
location[1] <<- st_cast(st_nearest_points(location, target$geometry), "POINT")[[2]] # set location to patch location
visitSeq <<- c(visitSeq, as.character(target$NAME)) #add patch to visitSeq
targeting <<- FALSE
} else location[1] <<- location + 2 * speed * c(cos(bearing), sin(bearing)) #otherwise, move closer
} else { #if not targeting
bearing <<- as.numeric(rcircularuniform(1))
location[1] <<- location + rgamma(1, shape = 1, scale = speed) * c(cos(bearing), sin(bearing))
if (!is.na(bounds)){ #check for valid bounds
while(! st_within(location, bounds, sparse = FALSE)[1,1]) {#check if out of bounds
location[1] <<- st_point(path[[1]][nrow(path[[1]]),]) #reset location
bearing <<- as.numeric(rcircularuniform(1))
location[1] <<- location + rgamma(1, shape = 1, scale = speed) * c(cos(bearing), sin(bearing))
}
}
}
path[[1]] <<- st_multipoint(rbind(path[[1]], location[[1]]))
attr(path, "bbox") <<- setNames(unlist(bbox(as_Spatial(path))), c("xmin", "ymin", "xmax", "ymax"))
attr(location, "bbox") <<- setNames(unlist(bbox(as_Spatial(location))), c("xmin", "ymin", "xmax", "ymax"))
},
plot = function(){ "plots the location and path of the forager"
fPlot <-ggplot() + geom_sf(data = location, shape = 13, size = 4) + geom_sf(data = st_cast(path, "LINESTRING")) + theme_classic()
return(fPlot)
})
)
#' @field repeatAvoid numeric giving the number of different patches a forager must visit before targeting a recently visited patch again
#' @field target a simple feature data frame with a single row containing the target patch location and values
#' @field turnBias a numeric giving the radians from which the center of the wrapped cauchy distribution from which new bearings are drawn should be shifted from the previous bearing.
#' @field persistence a numeric between 0 and one which gives the concentration of the wrapped cauchy distribution from which new bearings are drawn, where a 1 results in a turning angle equal to turnBias every step and a 0 results in a circular random uniform probability distribution
#' @export
#' @export BRWForager
#' @import methods
#' @importFrom circular circular rcircularuniform rwrappedcauchy
#' @import sp
#' @import ggplot2
BRWForager <- setRefClass("brwForager", fields = list(turnBias = "numeric", persistence = "numeric"), contains = "Forager",
methods = list(
initialize = function(..., turnBias = 0, persistence = 0.6) {
callSuper(..., turnBias = turnBias, persistence = persistence)
},
move = function(bounds = NA){
if (targeting) { #if a target is given, assess proximity and action
bearing <<- lineBearing(st_nearest_points(st_set_crs(st_sfc(location), st_crs(target)), target)) #set bearing toward target
if (abs(set_units(st_distance(location, target$geometry), NULL)) <= 2 * speed) { #if target is in reach
location[1] <<- st_cast(st_nearest_points(location, target$geometry), "POINT")[[2]] # set location to patch location
visitSeq <<- c(visitSeq, as.character(target$NAME)) #add patch to visitSeq
targeting <<- FALSE
} else location[1] <<- location + speed * c(cos(bearing), sin(bearing)) #otherwise, move closer
} else { #if not targeting
bearing <<- as.numeric(circular(bearing) + rwrappedcauchy(n = 1, mu = as.circular(turnBias, type = "angles", units = "radians", template = "none", zero = 0, modulo = "asis", rotation = "counter"), rho = persistence))
location[1] <<- location + speed * c(cos(bearing), sin(bearing))
if (!is.na(bounds)){ #check for valid bounds
turnVarIncrease <- 0
while(! st_within(location, bounds, sparse = FALSE)[1,1]) {#check if out of bounds
location[1] <<- st_point(path[[1]][nrow(path[[1]]),]) #reset location
if(persistence-turnVarIncrease > 0.2) turnVarIncrease <- turnVarIncrease + 0.02 #relax directional persistence
bearing <<- as.numeric(circular(bearing) + rwrappedcauchy(n = 1, mu = circular(0), rho = persistence - turnVarIncrease)) # get new bearing
location[1] <<- location + speed * c(cos(bearing), sin(bearing)) #try moving again
}
}
}
path[[1]] <<- st_multipoint(rbind(path[[1]], location[[1]]))
attr(path, "bbox") <<- setNames(unlist(bbox(as_Spatial(path))), c("xmin", "ymin", "xmax", "ymax"))
attr(location, "bbox") <<- setNames(unlist(bbox(as_Spatial(location))), c("xmin", "ymin", "xmax", "ymax"))
})
)
#' @field speed A numeric value that gives the scale parameter of the gamma distribution from which step lengths are draw. Because the shape parameter of this distribution is set to 1, the speed variable will equal the average step length
#' @field sight A numeric giving the distance at which the forager object can detect patches when in an environment
#' @field path A simple features collection with a single multipoint object containing previous locations of the forager. Usually objects are created with default multipoint objects containing only the initial location
#' @field visitSeq A character vector with the names (in order) of all patches visited. Must start with NAs equal in number to to the repeatAvoid variable (this is done by default if no value is given)
#' @field targeting A logical giving which mode of movement the forager is in. Initial value usually uses default "FALSE"
#' @field repeatAvoid Numeric giving the number of different patches a forager must visit before targeting a recently visited patch again
#' @field target A simple feature data frame with a single row containing the target patch location and values
#' @export
#' @export dForager
#' @import methods
dForager <- setRefClass("distanceForager", fields = list(), contains = "Forager",
methods = list(
tSelect = function(choices) {
if (sum(choices$DIST == 0) > 0) return(choices[which(choices$DIST == 0),][1,])                                         #if on a patch, return that patch as target. If on multiple, return the first
choices$prob <- choices$DIST^3/sum(choices$DIST^3) #distance discounted choice
return(selector(choices))
}))
#' @field repeatAvoid numeric giving the number of different patches a forager must visit before targeting a recently visited patch again
#' @field target a simple feature data frame with a single row containing the target patch location and values
#' @field turnBias a numeric giving the radians from which the center of the wrapped cauchy distribution from which new bearings are drawn should be shifted from the previous bearing.
#' @field persistence a numeric between 0 and one which gives the concentration of the wrapped cauchy distribution from which new bearings are drawn, where a 1 results in a turning angle equal to turnBias every step and a 0 results in a circular random uniform probability distribution
#' @export
#' @export DDBRWForager
#' @import methods
#' @importFrom circular circular rcircularuniform rwrappedcauchy
#' @import sp
#' @import ggplot2
DDBRWForager <- setRefClass("ddbrwForager", contains = "brwForager",
methods = list(
initialize = function(...) {
callSuper(...)
},
tSelect = function(choices) {
if (sum(choices$DIST == 0) > 0) return(choices[which(choices$DIST == 0),][1,])                                         #if on a patch, return that patch as target. If on multiple, return the first
choices$prob <- choices$DIST^3/sum(choices$DIST^3) #distance discounted choice
return(selector(choices))
})
)
# Function to make a selection given a set of probabilities
#
#' @param choices a datafame with a column named "prob". Values in this column should be numeric and and up to 1.
selector <- function(choices){
randomizer <- runif(1)
i = 1
while(choices$prob[i] <= randomizer) {
randomizer <- randomizer - choices$prob[i]
i <- i + 1
}
return(choices[i,])
}
# Function to calculate distance between a forager and a set of patches, then return the patches withing sight range of the forager and their distances
#
#' @param forager A single object of Forager class
#' @param patches A simple features data frame with a geom column containing the geometries of patches.
#' @importFrom units set_units
getChoices <- function(forager, patches) {
recentVisits <- forager$visitSeq[c((length(forager$visitSeq) - (forager$repeatAvoid - 1)):length(forager$visitSeq))] #check which patches forager has visited recently
patches <- patches[! patches$NAME %in% recentVisits,] #remove recently visited patches
distances <- set_units(st_distance(forager$location, patches), NULL) #get distances to each patch
if (sum(distances <= forager$sight) == 0) return(NA)                                                                        #if no patches in sight, return no target
choices <- patches[which(distances[1,] <= forager$sight),]
choices$DIST <- distances[distances[1,] <= forager$sight]
return(choices)
}
# Function to get the bearing from the start point of a linestring to the endpoint
#
#' @param linestring A st_LINESTRING object
lineBearing <- function(linestring) {
endpoints <- st_cast(linestring, "POINT")
deltaXY <- endpoints[[2]] - endpoints[[1]]
return(atan2(x = deltaXY[1], y = deltaXY[2]))
}
#' @param bearings A single numeric giving the initial bearing of all new foragers in radians or a list of numerics equal in length to the value of numForagers
#' @param speeds A single numeric giving the initial speed of all new foragers or a list of numerics equal in length to the value of numForagers
#' @param persistences A single numeric giving the initial persistence of all new foragers or a list of numerics equal in length to the value of numForagers. Ignored unless type = "BRW"
#' @param sights A single numeric giving the initial sight range of all new foragers or a list of numerics equal in length to the value of numForagers
#' @param repeatAvoids A single numeric giving the number of unique patches a forager must visit before revisting a patch, or a list of numerics equal in length to the value of numForagers
#' @param quiet A logical indicating whether to suppress warnings about default values used to fill in empty fields
#' @param CRS A numeric giving the CRS code to assign to forager locations. If bounds argument is defined, the CRS of that object will be used and this argument will be ignored
#' @param turnBiases A single numeric giving the average turn angle of a forager in radians, or a list of numerics equal in length to the value of numForagers. Ignored unless type = "BRW"
#' @export
#' @importFrom circular circular rcircularuniform rwrappedcauchy
createForagers <- function(numForagers, type = "Random", bounds = NA, locations = NA, bearings = NA, speeds = NA, persistences = NA, sights = NA, repeatAvoids = NA, quiet = FALSE, CRS = "NA", turnBiases = NA) {
if (is.na(bearings)) {
if (! quiet) warning("No bearings given, initial values drawn from circular random uniform distribution")
bearings <- as.numeric(rwrappedcauchy(n = numForagers, mu = circular(0), rho = 0))
}
if(is.na(speeds)) {
if (! quiet) warning("No speeds given, initial values set to 1")
speeds <- 1
}
if (is.na(sights)) {
if (! quiet) warning("No sight ranges given, initial values set to 5")
sights <- 5
}
if (is.na(repeatAvoids)) {
if (! quiet) warning("No patch avoidance memory given. Initial values set to avoid 2 most recently visited patches")
repeatAvoids <-  2
}
if (is.na(locations)) {
if (is.na(bounds)) {
if (! quiet) warning("No bounds or locations given. Bounds set from -50 to 50 for x and y axes by default")
bounds <- st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = CRS)
}
locations <- vector("list", length = numForagers)
for(i in 1:length(locations)) locations[[i]] <- generateBoundedPoint(bounds)
} else {
if ("data.frame" %in% class(locations)) {
if(!ncol(locations) == 2) stop("locations argument must be either a list of coordinate pairs, a list of spatial points, or a dataframe with 2 columns for x and y coodinates respectively")
locationPoints <- vector("list", length = nrow(locations))
for (i in 1:length(locationPoints)) locationsPoints[[i]] <- st_point(locations[i,])
locations <- locationPoints
}
}
if (type == "BRW"){
if(is.na(persistences)){
if (! quiet) warning("No turning persistences given, initial values set to 0.7")
persistences <- 0.7
}
if(is.na(turnBiases)){
if (! quiet) warning("No turning biases given, initial values set to 0")
turnBiases <- 0
}
}
if(!length(locations) == numForagers) stop("number of locations given must equal value of numForagers argument")
locations <- lapply(locations, to_sf_point, crs = st_crs(bounds))
foragers <- vector("list", length = numForagers)
parameters <- st_sf(geom = reduce(locations,c), BEARING = bearings, SPEED = speeds, PERSISTENCE = persistences, SIGHT = sights, REPEATAVOID = repeatAvoids, BIAS = turnBiases)
if(type == "Random") for (i in 1:numForagers) foragers[[i]] <- Forager(location=parameters$geom[i], bearing = parameters$BEARING[i], speed = parameters$SPEED[i], sight = parameters$SIGHT[i], repeatAvoid = parameters$REPEATAVOID[i])
if(type == "BRW") for (i in 1:numForagers) foragers[[i]] <- BRWForager(location=parameters$geom[i], bearing = parameters$BEARING[i], speed = parameters$SPEED[i], sight = parameters$SIGHT[i], repeatAvoid = parameters$REPEATAVOID[i], persistence = parameters$PERSISTENCE[i], turnBias = parameters$BIAS[i])
return(foragers)
}
# Function to flexibly handle multiple point formats and converts to a simple features collection
#
#' @param point A length two numeric vector, an st_POINT, or and sfc_POINT class object
#' @param crs A numeric giving the CRS code to apply to the point argument
to_sf_point <- function(point, crs = NA) {
if (is.numeric(point)) {
if (!length(point) == 2) stop("point argument is numeric, but not of length 2")
point <- st_point(point)
}
if ("POINT" %in% class(point)) point <- st_sfc(point, crs = crs)
if ("sfc_POINT" %in% class(point)) return(point) else stop("point argument must be a numeric vector, a POINT object, or a geometry collection with POINT objects")
}
# Function to create a simple features collection containing a single point created randomly within a set of polygons
#
#' @param bounds A simple features collection containing polygons within which new point must be created.
#' @importFrom stats runif
generateBoundedPoint <- function(bounds) {
location <- c(runif(1, st_bbox(bounds)["xmin"], st_bbox(bounds)["xmax"]), runif(1, st_bbox(bounds)["ymin"], st_bbox(bounds)["ymax"])) %>% st_point() %>% st_sfc(crs = st_crs(bounds))
while (!st_within(location, bounds, sparse = FALSE)[1,1]) location <- c(runif(1, st_bbox(bounds)["xmin"], st_bbox(bounds)["xmax"]), runif(1, st_bbox(bounds)["ymin"], st_bbox(bounds)["ymax"])) %>% st_point() %>% st_sfc(crs = st_crs(bounds)) #if point not within bounds, recreate
return(location)
}
test <- Environment()
test$progress()
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("backports")
install.packages("backports")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("backports")
install.packages("sf")
library(devtools)
install_github("aqvining/Foraging-Simulator")
library(devtools)
install.packages(devtools)
install.packages("devtools")
library(devtools)
install.packages("backports")
library(devtools)
install_github("aqvining/Foraging-Simulator")
library(ForageR) #can be installed using devtools::install_github("aqvining/Foraging-Simulator")
filterout <- function(Ldata){
for (i in 2:length(Ldata)){
if(Ldata[i] == Ldata[i-1] ){Ldata[i - 1]= NA}
}
Ldata=Ldata[!is.na(Ldata)]
Ldata
}
library(spatstat)
library(ggplot2)
determinism <- function(x, minl){
x = as.numeric(x)
#Depending on the dataset it may be desirable to filter out consecutive visits
#to the same flower. See function below and delete '#' in the line below to use
x = filterout(Ldata = x)
#-----set up matrix resembling a recurrence plot, where a 1 indicates a repeat
#-----visit and 0 indicates the absence of a repeat.
#if (length(unique(x)) < minl) return(NA)
#if (length(x) <= 3*minl) return(NA)
#if (length(unique(x)) == length(x)) return(0)
det1 = matrix(cbind(rep(x,length(x))),nrow=length(x))
tdet = t(det1)
det = ((det1 - tdet) == 0) * 1
#set the main diagonal equal to zero so it won't be included in the calculation
diag(det) = 0
#Use spatstat package to create a 'countour map' of the matrix,
#which assigns all sets of contiguous 1's a unique number
yi <- as.im(det)
ycOut <- connected(yi, background = 0)
yc <- ycOut$v
#Depending on the dataset it may be desirable to filter out diagonals perpendicular to #the main diagonal. Code is provided for the 'removeperpdiag' function below.
#Delete "#" from the line below to filter out perpendicular diagonals
#yc = removeperpdiag(yc,minl)
#Note: this code may take several minutes to run for very long sequences
#---- filter out short repeats: a 'trapline' should include more unique resources
#---- than the minimum cutoff (minl)
#make an alternative DET matrix that contains the resource IDs
det2 = matrix(rep(x,nrow(det)),nrow=nrow(det),byrow=TRUE)*det
#make a dataframe with the number of times each resource appears in a diagonal
listofseq = data.frame(group = yc[1:length(yc)], seq=det2[1:length(det2)])
#how many unique resources are in the diagonal
uniquevisits = rowSums((table(listofseq)>0)*1)
#only count diagonals with at least 'minl' number of unique resources
longenough = (uniquevisits >= minl)*table(yc)
#find the numerator:
#(remember this still includes both the top and bottom halves of the matrix)
contig = sum(longenough)
denominator= sum(det)
#This also still includes top and bottom halves of the matrix
#------------------- total DET score
#divide the numerator and denominator in half before calculating DET for just
#the top half of the matrix
return((contig/2)/(denominator/2))
}
##Run simulation w/ high sight only
setwd("~/Manuscripts/Traplining Vervets/Simulations/DT High Sight")
parametersDThighSight <- list(distanceForager = c(TRUE, FALSE))
simsPer <- 500
DTSimHighSight <- data.frame(matrix(nrow = prod(sapply(parametersDThighSight, length)) * simsPer, ncol = 1 + length(parametersDThighSight)))
colnames(DTSimHighSight) <- c("DET", "distanceForager")
sequences = vector("list", length = nrow(DTSimHighSight))
i = 0
for (dFor in parametersDThighSight$distanceForager) {
for (j in 1:simsPer) {
#setup
i <- i+1
print(paste("running simulation ", i, "dFor = ", dFor))
if (dFor) { foragers <- list(DDBRWForager(location = st_sfc(st_point(runif(2, -15,15))), sight = 25, persistence = 0.6, turnBias = 0, repeatAvoid = 2, speed = 4))
} else foragers <- list(BRWForager(location = st_sfc(st_point(runif(2, -15,15))), sight = 25, persistence = 0.6, turnBias = 0, repeatAvoid = 2, speed = 4))
patches <- st_sf(geometry = st_buffer(st_sfc(lapply(list(c(-1,4),c(8,7),c(-11,11),c(1,-7),c(11,-10),c(-3,-11)), st_point)), dist = 0.2), NAME = as.character(1:6))
trialEnviron <- ArrayEnvironment(foragers = foragers, patches = patches, bounds = st_sfc(st_polygon(list(matrix(c(15,15,15,-15,-15,-15,-15,15,15,15), byrow = TRUE, ncol = 2)))))
#update
while(trialEnviron$trials < 10) {
trialEnviron$progress()
}
DTSimHighSight[i,] <- c(NA, dFor)
sequences[[i]] <- trialEnviron$sequence
#plot
plt <- trialEnviron$plotPaths() + ggtitle(paste("dFor = ", dFor, "Sim",i))
png(paste("dFor = ", dFor, "Sim",i,".png"))
print(plt)
dev.off()
}
}
if (dFor) { foragers <- list(DDBRWForager(location = st_sfc(st_point(runif(2, -15,15))), sight = 25, persistence = 0.6, turnBias = 0, repeatAvoid = 2, speed = 4))
} else foragers <- list(BRWForager(location = st_sfc(st_point(runif(2, -15,15))), sight = 25, persistence = 0.6, turnBias = 0, repeatAvoid = 2, speed = 4))
patches <- st_sf(geometry = st_buffer(st_sfc(lapply(list(c(-1,4),c(8,7),c(-11,11),c(1,-7),c(11,-10),c(-3,-11)), st_point)), dist = 0.2), NAME = as.character(1:6))
trialEnviron <- ArrayEnvironment(foragers = foragers, patches = patches, bounds = st_sfc(st_polygon(list(matrix(c(15,15,15,-15,-15,-15,-15,15,15,15), byrow = TRUE, ncol = 2)))))
trialEnviron$progress()
#update
while(trialEnviron$trials < 10) {
trialEnviron$progress()
}
trialEnviron$progress()
setwd("~/Foraging Simulator")
library(roxygen2)
build()
install_github("aqvining/Foraging-Simulator")
library(ForageR) #can be installed using devtools::install_github("aqvining/Foraging-Simulator")
