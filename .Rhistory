l = vector("list", n)
for (i in 1:n)
l[[i]] = p + 10 * runif(2)
l
s = st_sfc(l)
s
plot(p)
plot(s)
plot(s, col = sf.colors(categorical = TRUE, alpha = .5))
d = st_difference(s)
d
plot(d, col = sf.colors(categorical = TRUE, alpha = .5))
lstring <- st_zm(movement_sf$geom[1])
lstring[1]
lstring[[1]]
lstring-lstring
lstring+lstring
st_distance(lstring)
lstring[-1]
lstring
lstring - lstring
s1 = rbind(c(0,3),c(0,4),c(1,5),c(2,5))
ls = st_linestring(s1)
seg = st_segments(ls)
install.packages("nngeo")
library(nngeo)
seg = st_segments(ls)
seg
line_bearing(st_segments(movement_sf[1,]))
warnings()
diff(line_bearing(st_segments(movement_sf[1,])))
st_segments(movement_sf)
st_segments(movement_sf[1:5,])
line_bearing(st_segments(movement_sf[1:5,]))
View(movement_sf)
View(movement_sf)
?summarize
?sf_summarize
?sf_summarise
seg
st_length(seg)
st_length(st_linesting(matrix(c(0,0,0,2,2,2), ncol = 2, byrow = TRUE)))
st_length(st_linestring(matrix(c(0,0,0,2,2,2), ncol = 2, byrow = TRUE)))
movements <- st_segments(movement_sf) %>% mutate(displacement = st_length(result), turn = line_bearing(result))
?ddply
diff(c(1,2,5))
diff(matrix(c(1,2,5,2,3,6), ncol = 2))
?group_modify
?diff
displacements <- Movement_All %>% group_by(individual.local.idenfier, day) %>% select(location.long, location.lat) %>% group_modify(~ diff(.x, lag = 1))
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(location.long, location.lat) %>% group_modify(~ diff(.x, lag = 1))
data.frame(matrix(c(1,2,5,2,3,6), ncol = 2))
diff(data.frame(matrix(c(1,2,5,2,3,6), ncol = 2)))
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(location.long, location.lat) %>% group_modify(~ diff(as.matrix(.x), lag = 1))
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(location.long, location.lat) %>% group_modify(~ data.frame(diff(as.matrix(.x), lag = 1)))
View(displacements)
Movement_UTM <- project(as.matrix(Movement_All[,c(3,4)]), "+proj=utm +zone=17N ellps=WGS84")
Movement_All[,c(3,4)] <- Movement_UTM #update long and lat columns
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(location.long, location.lat) %>% group_modify(~ data.frame(diff(as.matrix(.x), lag = 1)))
diff(Movement_All$timestamp)
timeDiff <- diff(as.POSIXct(Movement_All$timestamp))
summary(timeDiff)
timeDiff
Movement_All <- mutate(Movement_All, timestamp = as.POSIXct(timestamp))
diff(Movement_All$timestamp)
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(timestamp, location.long, location.lat) %>% group_modify(~ data.frame(diff(as.matrix(.x), lag = 1)))
Movement_All <- mutate(Movement_All, timestamp_numeric = as.numeric(as.POSIXct(timestamp)))
displacements <- Movement_All %>% group_by(individual.local.identifier, day) %>% select(timestamp_numeric, location.long, location.lat) %>% group_modify(~ data.frame(diff(as.matrix(.x), lag = 1)))
View(displacements)
summary(displacements$timestamp_numeric)
displacements <- displacements %>% mutate(location.long = location.long * timestamp_numeric/240, location.lat = location.lat * timestamp_numeric/240)
summary(displacements)
?filter
displacements <- Movement_All %>%
group_by(individual.local.identifier, day) %>% #each group is an animals movement over one day
select(timestamp_numeric, location.long, location.lat) %>%
group_modify(~ data.frame(diff(as.matrix(.x), lag = 1))) %>% #get lagged differences in time, long, and lat for each days movement
filter(timestamp_numeric >= 180 & timestamp <= 300) #remove any displacements that were not between three and five minutes in length
displacements <- Movement_All %>%
group_by(individual.local.identifier, day) %>% #each group is an animals movement over one day
select(timestamp_numeric, location.long, location.lat) %>%
group_modify(~ data.frame(diff(as.matrix(.x), lag = 1))) %>% #get lagged differences in time, long, and lat for each days movement
filter(timestamp_numeric >= 180 & timestamp_numeric <= 300) #remove any displacements that were not between three and five minutes in length
displacements <- displacements %>% mutate(location.long = location.long * timestamp_numeric/240, location.lat = location.lat * timestamp_numeric/240)
summary(displacements)
hist(displacements$location.long)
table(displacements$location.long)
table(hist(displacements$location.long))
?arima
?group_map
displacements <- Movement_All %>%
group_by(individual.local.identifier, day) %>% #each group is an animals movement over one day
select(timestamp_numeric, location.long, location.lat) %>%
group_modify(~ data.frame(diff(as.matrix(.x), lag = 1))) %>% #get lagged differences in time, long, and lat for each days movement
filter(timestamp_numeric >= 180 & timestamp_numeric <= 300) %>% #remove any displacements that were not between three and five minutes in length
ungroup()
View(displacements)
View(displacements)
displacements <- displacements %>% mutate(location.long = location.long * timestamp_numeric/240, location.lat = location.lat * timestamp_numeric/240)
?arima
AR1models <- displacements %>% group_by(individual.local.identifier) %>% group_modify(~ broom::tidy(arima(.x, order = c(1, 0, 0))))
AR1models <- displacements %>% group_by(individual.local.identifier) %>% group_map(~ arima(.x, order = c(1, 0, 0)))
AR1models <- displacements %>% group_by(individual.local.identifier) %>% group_map(~ arima(.x$location.long, order = c(1, 0, 0)))
AR1models[[1]]
names(AR1models)
install.packages("broom")
install.packages("broom")
library(broom)
install.packages("broom")
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
library(sf)
library(sp)
library(ggplot2)
library(geosphere)
library(stplanr)
library(units)
library(spatstat)
library(broom)
install.packages(c("dplyr", "ggplot2", "maptools", "purrr", "raster", "rgdal", "rgeos", "rlang", "rmarkdown", "sf", "sp", "spData", "tibble"))
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
library(sf)
library(sp)
library(ggplot2)
library(geosphere)
library(stplanr)
library(units)
library(spatstat)
setwd("~/")
library(broom)
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
install.packages("rlang")
install.packages("rlang")
library(rlang)
library(plyr)
library(dplyr)
install.packages("rlang")
install.packages("rlang")
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
library(spData)
library(rgdal) # requires sp, will use proj.4 if installed
library(spData)
library(purrr)
library(circular)
library(plyr)
library(dplyr)
library(sf)
install.packages("vctrs")
library(devtools)
install_github("aqvining/Foraging-Simulator")
library(devtools)
install_github("aqvining/Foraging-Simulator")
library(devtools)
library(devtools)
install.packages(ellipsis)
install.packages("ellipsis")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("ps")
install.packages("ps")
install_github("aqvining/Foraging-Simulator")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("processx")
install.packages("processx")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("pkgload")
install.packages("pkgload")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("glue")
install.packages("glue")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install.packages("glue")
library(devtools)
install_github("aqvining/Foraging-Simulator")
install_github("aqvining/Foraging-Simulator")
?stplanr
??stplanr
testEnvironment <- Environment()
library(ForageR)
test <- Environment()
test <- createForagers(3)
#' @param bearings A single numeric giving the initial bearing of all new foragers in radians or a list of numerics equal in length to the value of numForagers
#' @param speeds A single numeric giving the initial speed of all new foragers or a list of numerics equal in length to the value of numForagers
#' @param persistences A single numeric giving the initial persistence of all new foragers or a list of numerics equal in length to the value of numForagers. Ignored unless type = "BRW"
#' @param sights A single numeric giving the initial sight range of all new foragers or a list of numerics equal in length to the value of numForagers
#' @param repeatAvoids A single numeric giving the number of unique patches a forager must visit before revisting a patch, or a list of numerics equal in length to the value of numForagers
#' @param quiet A logical indicating whether to suppress warnings about default values used to fill in empty fields
#' @param CRS A numeric giving the CRS code to assign to forager locations. If bounds argument is defined, the CRS of that object will be used and this argument will be ignored
#' @param turnBiases A single numeric giving the average turn angle of a forager in radians, or a list of numerics equal in length to the value of numForagers. Ignored unless type = "BRW"
#' @export
#' @importFrom circular circular rcircularuniform rwrappedcauchy
createForagers <- function(numForagers, type = "Random", bounds = NA, locations = NA, bearings = NA, speeds = NA, persistences = NA, sights = NA, repeatAvoids = NA, quiet = FALSE, CRS = NA, turnBiases = NA) {
if (is.na(bearings)) {
if (! quiet) warning("No bearings given, initial values drawn from circular random uniform distribution")
bearings <- as.numeric(rwrappedcauchy(n = numForagers, mu = circular(0), rho = 0))
}
if(is.na(speeds)) {
if (! quiet) warning("No speeds given, initial values set to 1")
speeds <- 1
}
if (is.na(sights)) {
if (! quiet) warning("No sight ranges given, initial values set to 5")
sights <- 5
}
if (is.na(repeatAvoids)) {
if (! quiet) warning("No patch avoidance memory given. Initial values set to avoid 2 most recently visited patches")
repeatAvoids <-  2
}
if (is.na(locations)) {
if (is.na(bounds)) {
if (! quiet) warning("No bounds or locations given. Bounds set from -50 to 50 for x and y axes by default")
bounds <- st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = CRS)
}
locations <- vector("list", length = numForagers)
for(i in 1:length(locations)) locations[[i]] <- generateBoundedPoint(bounds)
} else {
if ("data.frame" %in% class(locations)) {
if(!ncol(locations) == 2) stop("locations argument must be either a list of coordinate pairs, a list of spatial points, or a dataframe with 2 columns for x and y coodinates respectively")
locationPoints <- vector("list", length = nrow(locations))
for (i in 1:length(locationPoints)) locationsPoints[[i]] <- st_point(locations[i,])
locations <- locationPoints
}
}
if (type == "BRW"){
if(is.na(persistences)){
if (! quiet) warning("No turning persistences given, initial values set to 0.7")
persistences <- 0.7
}
if(is.na(turnBiases)){
if (! quiet) warning("No turning biases given, initial values set to 0")
turnBiases <- 0
}
}
if(!length(locations) == numForagers) stop("number of locations given must equal value of numForagers argument")
locations <- lapply(locations, to_sf_point, crs = st_crs(bounds))
foragers <- vector("list", length = numForagers)
parameters <- st_sf(geom = reduce(locations,c), BEARING = bearings, SPEED = speeds, PERSISTENCE = persistences, SIGHT = sights, REPEATAVOID = repeatAvoids, BIAS = turnBiases)
if(type == "Random") for (i in 1:numForagers) foragers[[i]] <- Forager(location=parameters$geom[i], bearing = parameters$BEARING[i], speed = parameters$SPEED[i], sight = parameters$SIGHT[i], repeatAvoid = parameters$REPEATAVOID[i])
if(type == "BRW") for (i in 1:numForagers) foragers[[i]] <- BRWForager(location=parameters$geom[i], bearing = parameters$BEARING[i], speed = parameters$SPEED[i], sight = parameters$SIGHT[i], repeatAvoid = parameters$REPEATAVOID[i], persistence = parameters$PERSISTENCE[i], turnBias = parameters$BIAS[i])
return(foragers)
}
createForagers()
library(circular)
createForagers()
createForagers(3)
is.character(NA)
st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = 4623)
st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = NA)
st_sfc(st_polygon(list(matrix(c(50, 50, -50, 50, -50, -50, 50, -50, 50, 50), ncol = 2, byrow = TRUE))), crs = "NA")
Environment()
new("Environement")
new("Environment")
library(roxygen2)
#empirical data analysis
setwd("~/Manuscripts/Traplining Vervets")
PrimateDET_Data <- read.csv("DET data.csv") #this is the DET data tab saved as a csv
PrimateDET_Data$Seq <- strsplit(as.character(PrimateDET_Data$Seq), split = ",") #turn vector of factors into list of character vectors
PrimateDET_Data <- PrimateDET_Data[1:183, 1:8] #remove extraneous rows and columns(note stray value in row 73)
PrimateDET_cleaned <- PrimateDET_Data[sapply(PrimateDET_Data$Bin.of.10, function(X) X %in% c(1:20)),] #removes incomplete bins. Including partial sets requires some thought - probably simulating sequences with each possible number of trials. Shouldn't be too hard
PrimateDET_cleaned$DET2 <- sapply(PrimateDET_cleaned$Seq, determinism, minl = 2)
filterout <- function(Ldata){
for (i in 2:length(Ldata)){
if(Ldata[i] == Ldata[i-1] ){Ldata[i - 1]= NA}
}
Ldata=Ldata[!is.na(Ldata)]
Ldata
}
library(spatstat)
library(ggplot2)
determinism <- function(x, minl){
x = as.numeric(x)
#Depending on the dataset it may be desirable to filter out consecutive visits
#to the same flower. See function below and delete '#' in the line below to use
x = filterout(Ldata = x)
#-----set up matrix resembling a recurrence plot, where a 1 indicates a repeat
#-----visit and 0 indicates the absence of a repeat.
#if (length(unique(x)) < minl) return(NA)
#if (length(x) <= 3*minl) return(NA)
#if (length(unique(x)) == length(x)) return(0)
det1 = matrix(cbind(rep(x,length(x))),nrow=length(x))
tdet = t(det1)
det = ((det1 - tdet) == 0) * 1
#set the main diagonal equal to zero so it won't be included in the calculation
diag(det) = 0
#Use spatstat package to create a 'countour map' of the matrix,
#which assigns all sets of contiguous 1's a unique number
yi <- as.im(det)
ycOut <- connected(yi, background = 0)
yc <- ycOut$v
#Depending on the dataset it may be desirable to filter out diagonals perpendicular to #the main diagonal. Code is provided for the 'removeperpdiag' function below.
#Delete "#" from the line below to filter out perpendicular diagonals
#yc = removeperpdiag(yc,minl)
#Note: this code may take several minutes to run for very long sequences
#---- filter out short repeats: a 'trapline' should include more unique resources
#---- than the minimum cutoff (minl)
#make an alternative DET matrix that contains the resource IDs
det2 = matrix(rep(x,nrow(det)),nrow=nrow(det),byrow=TRUE)*det
#make a dataframe with the number of times each resource appears in a diagonal
listofseq = data.frame(group = yc[1:length(yc)], seq=det2[1:length(det2)])
#how many unique resources are in the diagonal
uniquevisits = rowSums((table(listofseq)>0)*1)
#only count diagonals with at least 'minl' number of unique resources
longenough = (uniquevisits >= minl)*table(yc)
#find the numerator:
#(remember this still includes both the top and bottom halves of the matrix)
contig = sum(longenough)
denominator= sum(det)
#This also still includes top and bottom halves of the matrix
#------------------- total DET score
#divide the numerator and denominator in half before calculating DET for just
#the top half of the matrix
return((contig/2)/(denominator/2))
}
PrimateDET_cleaned$DET2 <- sapply(PrimateDET_cleaned$Seq, determinism, minl = 2)
PrimateDET_cleaned$DET3 <- sapply(PrimateDET_cleaned$Seq, determinism, minl = 3)
PrimateDET_cleaned$DET4 <- sapply(PrimateDET_cleaned$Seq, determinism, minl = 4)
PrimateDET_cleaned$DET5 <- sapply(PrimateDET_cleaned$Seq, determinism, minl = 5)
PrimateDET_cleaned$DET6 <- sapply(PrimateDET_cleaned$Seq, determinism, minl = 6)
##Run simulation w/ high sight only
setwd("~/Manuscripts/Traplining Vervets/Simulations/DT High Sight")
DTSimHighSight <- read.csv("DTSimHighSight.csv")
DTSimHighSight$DET2 <- sapply(sequences, determinism, minl = 2)
View(DTSimHighSight)
View(DTSimHighSight)
parametersDThighSight <- list(distanceForager = c(TRUE, FALSE))
simsPer <- 500
DTSimHighSight <- data.frame(matrix(nrow = prod(sapply(parametersDThighSight, length)) * simsPer, ncol = 1 + length(parametersDThighSight)))
colnames(DTSimHighSight) <- c("DET", "distanceForager")
sequences = vector("list", length = nrow(DTSimHighSight))
i = 0
for (dFor in parametersDThighSight$distanceForager) {
for (j in 1:simsPer) {
#setup
i <- i+1
print(paste("running simulation ", i, "dFor = ", dFor))
if (dFor) { foragers <- list(dForager(location = runif(2, -15,15), sight = 25, turnDev = 0.6, repeatAvoid = 2, speed = 4))
} else foragers <- list(Forager(location = runif(2, -15,15), sight = 25, turnDev = 0.6, repeatAvoid = 2, speed = 4))
patches <-  list(Patch(location = c(-1,4), name = "1"), Patch(location = c(8,7), name = "2"),Patch(location = c(-11,11), name = "3"),Patch(location = c(1,-7), name = "4"), Patch(location = c(11,-10), name = "5"),Patch(location = c(-3,-11), name = "6"))
trialEnviron <- ArrayEnvironment(foragers = foragers, patches = patches, bounds = c(15,15), initPatches = 6)
#update
while(trialEnviron$trials < 10) {
trialEnviron$progress()
}
DTSimHighSight[i,] <- c(NA, dFor)
sequences[[i]] <- trialEnviron$sequence
#plot
plt <- trialEnviron$plotPaths() + ggtitle(paste("dFor = ", dFor, "Sim",i))
png(paste("dFor = ", dFor, "Sim",i,".png"))
print(plt)
dev.off()
}
}
library(ForagR)
library(ForageR)
parametersDThighSight <- list(distanceForager = c(TRUE, FALSE))
simsPer <- 500
DTSimHighSight <- data.frame(matrix(nrow = prod(sapply(parametersDThighSight, length)) * simsPer, ncol = 1 + length(parametersDThighSight)))
colnames(DTSimHighSight) <- c("DET", "distanceForager")
sequences = vector("list", length = nrow(DTSimHighSight))
i = 0
for (dFor in parametersDThighSight$distanceForager) {
for (j in 1:simsPer) {
#setup
i <- i+1
print(paste("running simulation ", i, "dFor = ", dFor))
if (dFor) { foragers <- list(dForager(location = runif(2, -15,15), sight = 25, turnDev = 0.6, repeatAvoid = 2, speed = 4))
} else foragers <- list(Forager(location = runif(2, -15,15), sight = 25, turnDev = 0.6, repeatAvoid = 2, speed = 4))
patches <-  list(Patch(location = c(-1,4), name = "1"), Patch(location = c(8,7), name = "2"),Patch(location = c(-11,11), name = "3"),Patch(location = c(1,-7), name = "4"), Patch(location = c(11,-10), name = "5"),Patch(location = c(-3,-11), name = "6"))
trialEnviron <- ArrayEnvironment(foragers = foragers, patches = patches, bounds = c(15,15), initPatches = 6)
#update
while(trialEnviron$trials < 10) {
trialEnviron$progress()
}
DTSimHighSight[i,] <- c(NA, dFor)
sequences[[i]] <- trialEnviron$sequence
#plot
plt <- trialEnviron$plotPaths() + ggtitle(paste("dFor = ", dFor, "Sim",i))
png(paste("dFor = ", dFor, "Sim",i,".png"))
print(plt)
dev.off()
}
}
#' @field visitSeq a character vector with the names (in order) of all patches visited. Must start with NAs equal in number to to the repeatAvoid variable (this is done by default if no value is given)
#' @field targeting a logical giving which mode of movement the forager is in. Initial value usually uses default "FALSE"
#' @field repeatAvoid numeric giving the number of different patches a forager must visit before targeting a recently visited patch again
#' @field target a simple feature data frame with a single row containing the target patch location and values
#' @export
#' @export Forager
#' @import methods
#' @importFrom circular circular rcircularuniform
#' @import sp
#' @import ggplot2
Forager <- setRefClass("Forager",
field = list(location="sfc", bearing ="numeric", speed = "numeric", sight = "numeric", path = "sfc", visitSeq = "character", targeting = "logical", repeatAvoid = "numeric", target = "sf"),
method = list(initialize = function(...,location = st_sfc(st_point(runif(2, -50, 50))),
bearing = as.numeric(rcircularuniform(1)),
speed = 1, #the mean distance traveled when moving randomly, drawn from a gamma distribution with k (shape) = 1, and theta(scale) = speed. When targeting, moves at 2X speed
sight = 4,
path = st_cast(location, "MULTIPOINT"),
repeatAvoid = 2,
visitSeq = rep("NA", times = repeatAvoid),#NA's prevent errors when checking for recent visits
targeting = FALSE,
target = st_sf(st_sfc(st_multipolygon()))) {
callSuper(..., location = location, bearing = bearing, speed = speed, sight = sight, path = path, visitSeq = visitSeq, targeting = targeting, target = target, repeatAvoid = repeatAvoid)
},
setTarget = function(patches) { "checks if the location of any simple features in the geometry column of the patches argument (class sfc) are within sight range.
If so, sets target to a patch randomly selected from those within sight and then sets the targetting field to TRUE"
if (! "sf" %in% class(patches)) stop("the 'patches' argument of setTarget must be a simple feature collection")
choices <- getChoices(.self, patches)
if (! "sf" %in% class(choices)) return()
target <<- tSelect(choices)
targeting <<- TRUE
},
tSelect = function(choices) { "calculates probablilites and selects a target from a list of options but DOES NOT set the target (use setTarget for this, which calls tSelect). A forager will always select a patch it is on if possible. Otherwise, selection is random"
if (sum(choices$DIST == 0) > 0) return(choices[which(choices$DIST == 0),][1,])     #if on a patch, return that patch as target. If on multiple, return the first
choices$prob <- rep(1/nrow(choices), times = nrow(choices)) #random choice
return(selector(choices))
},
move = function(bounds = NA) {"moves the forager using rules given in class description. Updates relevant fields including location, bearing, visitSeq, bearing, targetting, and path"
if (targeting) { #if a target is given, assess proximity and action
bearing <<- lineBearing(st_nearest_points(st_set_crs(st_sfc(location), st_crs(target)), target)) #set bearing toward target
if (abs(drop_units(st_distance(location, target$geometry))) <= 2 * speed) { #if target is in reach
location[1] <<- st_cast(st_nearest_points(location, target$geometry), "POINT")[[2]] # set location to patch location
visitSeq <<- c(visitSeq, as.character(target$NAME)) #add patch to visitSeq
targeting <<- FALSE
} else location[1] <<- location + 2 * speed * c(cos(bearing), sin(bearing)) #otherwise, move closer
} else { #if not targeting
bearing <<- as.numeric(rcircularuniform(1))
location[1] <<- location + rgamma(1, shape = 1, scale = speed) * c(cos(bearing), sin(bearing))
if (!is.na(bounds)){ #check for valid bounds
while(! st_within(location, bounds, sparse = FALSE)[1,1]) {#check if out of bounds
location[1] <<- st_point(path[[1]][nrow(path[[1]]),]) #reset location
bearing <<- as.numeric(rcircularuniform(1))
location[1] <<- location + rgamma(1, shape = 1, scale = speed) * c(cos(bearing), sin(bearing))
}
}
}
path[[1]] <<- st_multipoint(rbind(path[[1]], location[[1]]))
attr(path, "bbox") <<- setNames(unlist(bbox(as_Spatial(path))), c("xmin", "ymin", "xmax", "ymax"))
attr(location, "bbox") <<- setNames(unlist(bbox(as_Spatial(location))), c("xmin", "ymin", "xmax", "ymax"))
},
plot = function(){ "plots the location and path of the forager"
fPlot <-ggplot() + geom_sf(data = location, shape = 13, size = 4) + geom_sf(data = st_cast(path, "LINESTRING")) + theme_classic()
return(fPlot)
})
)
detach(Forager)
Forager(location = c(2,5))
library(circular)
Forager(location = c(2,5))
for (dFor in parametersDThighSight$distanceForager) {
for (j in 1:simsPer) {
#setup
i <- i+1
print(paste("running simulation ", i, "dFor = ", dFor))
if (dFor) { foragers <- list(dForager(location = st_sfc(st_point(runif(2, -15,15))), sight = 25, turnDev = 0.6, repeatAvoid = 2, speed = 4))
} else foragers <- list(Forager(location = st_sfc(st_point(runif(2, -15,15))), sight = 25, turnDev = 0.6, repeatAvoid = 2, speed = 4))
patches <-  list(Patch(location = c(-1,4), name = "1"), Patch(location = c(8,7), name = "2"),Patch(location = c(-11,11), name = "3"),Patch(location = c(1,-7), name = "4"), Patch(location = c(11,-10), name = "5"),Patch(location = c(-3,-11), name = "6"))
trialEnviron <- ArrayEnvironment(foragers = foragers, patches = patches, bounds = c(15,15), initPatches = 6)
#update
while(trialEnviron$trials < 10) {
trialEnviron$progress()
}
DTSimHighSight[i,] <- c(NA, dFor)
sequences[[i]] <- trialEnviron$sequence
#plot
plt <- trialEnviron$plotPaths() + ggtitle(paste("dFor = ", dFor, "Sim",i))
png(paste("dFor = ", dFor, "Sim",i,".png"))
print(plt)
dev.off()
}
}
library(devtools)
library(roxygen2)
document()
devtools::document()
setwd("~/Foraging Simulator")
document()
rm(Forager)
library(ForageR)
document()
detach(Forager)
detach("Forager")
?detach
Forager()
